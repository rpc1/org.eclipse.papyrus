/*****************************************************************************
 * Copyright (c) 2013, 2014 CEA LIST.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Camille Letavernier (CEA LIST) camille.letavernier@cea.fr - Initial API and implementation
 *****************************************************************************/
import RSAToPapyrus;
import org.eclipse.papyrus.m2m.qvto.Properties;

modeltype notation "strict" uses 'http://www.eclipse.org/gmf/runtime/1.0.2/notation';
modeltype umlNotation "strict" uses 'http://www.eclipse.org/papyrus/umlnotation';
modeltype uml "strict" uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype sash "strict" uses 'http://www.eclipse.org/papyrus/0.7.0/sashdi';
modeltype vpconfig "strict" uses 'http://www.eclipse.org/papyrus/infra/viewpoints/configuration';
modeltype vpstyle "strict" uses 'http://www.eclipse.org/papyrus/infra/viewpoints/policy/style';
modeltype config "strict" uses 'http:///RSAToPapyrusParameters.ecore';

transformation RSAClassDiagram(inout semantics : uml, inout graphics : notation, out di : sash, in param : config);

main() {
	semantics.rootObjects()[uml::Element]->map toOwnedDiagrams();
}

query View::getDiagramType() : String{
	return 'PapyrusUMLClassDiagram';
}



mapping notation::Diagram::generateDiagram() : notation::Diagram inherits Diagram::toPapyrusDiagram when {
	(self.type = 'Class' or self.type='Object') and not self.findElement().oclIsTypeOf(Profile)
}{

	end {
	
		/* Post action: Move AssociationClasses to the right parent (Dashed Edge + Node) */
		/* Easier to do in post-treatment than during the transformation (The transformation can remain generic) */
		result.map handleAssociationClasses();
		graphics.objectsOfType(Shape)->select(type = '2012').map addCommentDecoration();
		graphics.objectsOfType(Shape)->select(type = '2011').map addConstraintDecoration();
		if not result.element.oclIsKindOf(Package) then
			result.map toInnerClassDiagram()
		endif;
	}
}

mapping inout Diagram::toInnerClassDiagram() : PapyrusViewStyle{
	result.owner := self.element;
	result._configuration := getInnerClassDiagramView();
	
	self.styles += result;
}

query getInnerClassDiagramView() : PapyrusDiagram {
	return getEObjectProperty('InnerClassDiagramView').oclAsType(PapyrusDiagram);
}

mapping inout Shape::addCommentDecoration() when {
	self.type = '2012' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := '5038'; //Comment body
	}	

}

mapping inout Shape::addConstraintDecoration() when {
	self.type = '2011' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := '5159'; //Constraint specification
	}	

}

mapping inout Diagram::handleAssociationClasses() {
	graphics.objectsOfType(Shape)->select(type = '2013').map updateLocation();

	self.children := self.children->union(graphics.objectsOfType(Node)->select(type = '2013'));
	self.edges := self.edges->union(graphics.objectsOfType(Connector)->select(type = '4016'));
}

mapping inout Shape::updateLocation() {
	var dashedEdge := graphics.objectsOfType(Connector)->select(type = '4016' and source = self or target = self)->any(true);
	
	var association := dashedEdge.findConnector();
	
	var source := association.source.oclAsType(Shape);
	var target := association.target.oclAsType(Shape); 
	
	var sourcePosition := source.getBounds();
	var targetPosition := target.getBounds();
	
	var bounds := self.getBounds();
	
	bounds.x := (((sourcePosition.x + targetPosition.x)/2) + bounds.x).round(); 
	bounds.y := (((sourcePosition.y + targetPosition.y)/2) + bounds.y).round();
}
	
query Connector::findConnector() : Connector {
	var view := if self.source.oclIsKindOf(Connector) then self.source else self.target endif;
	return view.oclAsType(Connector);
}

query Shape::getBounds() : Bounds {
	return self.oclAsType(Shape).layoutConstraint.oclAsType(Bounds);
}

/**
*	In Papyrus, an AssociationClass is composed of two edges and a Node (Full edge for association, dashed edge for Association class, Node for the class)
*	In RSA, an AssociationClass is a single Edge with compartments
*/
mapping UMLConnector::toAssociationClass() : Connector inherits Connector::toPapyrusConnector when {
	self.element.oclIsTypeOf(AssociationClass)
}{
	result.styles := self.map toFontStyle();
	var dashedEdge := object Connector {
		type := '4016';
		target := self.children->selectByKind(UMLShape)->any(true).map toPapyrusShape();
		source := result;
		styles := object FontStyle{};
		bendpoints := object RelativeBendpoints{};
		sourceAnchor := object IdentityAnchor{};
		targetAnchor := object IdentityAnchor{};
		
	};
	

}


mapping Node::toNode() : Node disjuncts
	UMLShape::toPapyrusShape,
	UMLShapeCompartment::toStructureCompartment,
	BasicSemanticCompartment::toListCompartment,
	ListCompartment::toListCompartment,
	BasicDecorationNode::toConnectorLabel,
	BasicDecorationNode::toLabel
	//TODO: Disjunct nodes mapping
;

mapping Edge::toEdge() : Edge disjuncts
	UMLConnector::toCommentLink,
	UMLConnector::toConstraintLink,
	/*UMLConnector::toContextLink,*/
	UMLConnector::toPapyrusConnector,
	UMLConnector::toGeneralizationConnector,
	UMLConnector::toAssociationClass
;

mapping UMLShapeCompartment::toStructureCompartment() : DecorationNode inherits UMLShapeCompartment::toAbstractStructureCompartment when {
	self.type = 'StructureCompartment' or self.type = 'PackageContents' and not self.getType().oclIsUndefined();
}{
	
}


/***** Nodes **********/

mapping UMLShape::toPapyrusShape() : Shape inherits Shape::toPapyrusShape when {
	self.type = '' and (
		self.element.oclIsTypeOf(Dependency)or
	self.element.oclIsTypeOf(AssociationClass)or
	self.element.oclIsTypeOf(Association)or
	self.element.oclIsTypeOf(InstanceSpecification)or
	self.element.oclIsTypeOf(Component)or
	self.element.oclIsTypeOf(Signal)or
	self.element.oclIsTypeOf(Interface)or
	self.element.oclIsTypeOf(Model)or
	self.element.oclIsTypeOf(Enumeration)or
	self.element.oclIsTypeOf(Package)or
	self.element.oclIsTypeOf(InformationItem)or
	self.element.oclIsTypeOf(Class)or
	self.element.oclIsTypeOf(PrimitiveType)or
	self.element.oclIsTypeOf(DataType)or
	self.element.oclIsTypeOf(Constraint)or
	self.element.oclIsTypeOf(Comment)or
	self.element.oclIsTypeOf(Diagram)or
	self.element.oclIsTypeOf(DurationObservation)or
	self.element.oclIsTypeOf(TimeObservation)or
	self.element.oclIsKindOf(NamedElement)
	)
}{
	
}


/****** Connector Labels ******/

mapping BasicDecorationNode::toConnectorLabel() : DecorationNode inherits Node::toPapyrusConnectorLabel when {
		self.type = 'ToMultiplicityLabel' or
		self.type = 'ToRoleLabel' or
		self.type = 'FromMultiplicityLabel' or
		self.type = 'FromRoleLabel' or
		self.type = 'NameLabel' or
		self.type = 'KindLabel'
}{
	
}

/****** Compartments *******/

mapping BasicDecorationNode::toLabel() : DecorationNode inherits Node::toPapyrusNode when {
	self.element.oclIsKindOf(uml::NamedElement) and 
	self.type = 'Name'
}{
	
}

//Synchronized Compartments
mapping BasicSemanticCompartment::toListCompartment() : BasicCompartment inherits Node::toPapyrusNode, DrawerStyle::toDrawerStyle when {
	//TODO: EndsWith('Compartment')
	self.type = 'OperationCompartment' or
	self.type = 'SignalCompartment' or
	self.type = 'AttributeCompartment' or
	self.type.endsWith('Compartment')
}{
	result.children += self.findElement().map toContents(self);
}

//Standard Compartments (e.g. slots)
mapping ListCompartment::toListCompartment() : BasicCompartment inherits Node::toPapyrusNode, DrawerStyle::toDrawerStyle when {
	self.type.endsWith('Compartment')
} {
	//Super class implementation is sufficient. It will already transform the children and set the compartment ID
	result.children += self.findElement().map toContents(self);
}

mapping Element::toContents(node : ListCompartment) : Sequence(Node) disjuncts 
	InstanceSpecification::toContents
;

mapping Element::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	AssociationClass::toContents,
	Component::toContents,
	Signal::toContents,
	Interface::toContents,
	Enumeration::toContents,
	Class::toContents,
	PrimitiveType::toContents,
	DataType::toContents
;

mapping AssociationClass::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	AssociationClass::toAttributeCompartmentContents,
	AssociationClass::toOperationCompartmentContents,
	AssociationClass::toNestedClassifierCompartmentContents
;

mapping InstanceSpecification::toContents(node : ListCompartment) : Sequence(Node) disjuncts
	InstanceSpecification::toSlotCompartmentContents
;

mapping Component::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Component::toAttributeCompartmentContents,
	Component::toOperationCompartmentContents,
	Component::toNestedClassifierCompartmentContents
;

mapping Signal::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Signal::toAttributeCompartmentContents
;

mapping Interface::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Interface::toAttributeCompartmentContents,
	Interface::toOperationCompartmentContents,
	Interface::toNestedClassifierCompartmentContents
;

mapping Enumeration::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Enumeration::toEnumerationLiteralCompartmentContents
;

mapping Class::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Class::toAttributeCompartmentContents,
	Class::toOperationCompartmentContents,
	Class::toNestedClassifierCompartmentContents
;

mapping PrimitiveType::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	PrimitiveType::toAttributeCompartmentContents,
	PrimitiveType::toOperationCompartmentContents
;

mapping DataType::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	DataType::toAttributeCompartmentContents,
	DataType::toOperationCompartmentContents
;

mapping AssociationClass::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping AssociationClass::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	}
}

mapping AssociationClass::toNestedClassifierCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'SignalCompartment';
}{
	init {
		result := (self.map fillClass(node))
	}
}

mapping InstanceSpecification::toSlotCompartmentContents(node : ListCompartment) : Sequence(Node) when {
	node.type = 'SlotCompartment';
}{
	init {
		result := (self.map fillSlot(node))
	}
}

mapping Component::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping Component::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	->union(self.map fillReception(node))
	}
}

mapping Component::toNestedClassifierCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'SignalCompartment';
}{
	init {
		result := (self.map fillClass(node))
	->union(self.map fillInterface(node))
	->union(self.map fillEnumeration(node))
	->union(self.map fillPrimitiveType(node))
	->union(self.map fillDataType(node))
	->union(self.map fillSignal(node))
	}
}

mapping Signal::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping Interface::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping Interface::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	->union(self.map fillReception(node))
	}
}

mapping Interface::toNestedClassifierCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'SignalCompartment';
}{
	init {
		result := (self.map fillClass(node))
	->union(self.map fillInterface(node))
	->union(self.map fillEnumeration(node))
	->union(self.map fillPrimitiveType(node))
	->union(self.map fillDataType(node))
	->union(self.map fillSignal(node))
	}
}

mapping Enumeration::toEnumerationLiteralCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'EnumerationCompartment';
}{
	init {
		result := (self.map fillEnumerationLiteral(node))
	}
}

mapping Class::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping Class::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillReception(node))
	->union(self.map fillOperation(node))
	}
}

mapping Class::toNestedClassifierCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'SignalCompartment';
}{
	init {
		result := (self.map fillClass(node))
	->union(self.map fillInterface(node))
	->union(self.map fillEnumeration(node))
	->union(self.map fillPrimitiveType(node))
	->union(self.map fillDataType(node))
	->union(self.map fillSignal(node))
	}
}

mapping PrimitiveType::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping PrimitiveType::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	}
}

mapping DataType::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping DataType::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	}
}

mapping uml::Class::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInClass(node)->asSequence();
	}
}

mapping uml::Component::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInComponent(node)->asSequence();
	}
}

mapping uml::Signal::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInSignal(node)->asSequence();
	}
}

mapping uml::Interface::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInInterface(node)->asSequence();
	}
}

mapping uml::PrimitiveType::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInPrimitiveType(node)->asSequence();
	}
}

mapping uml::DataType::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInDataType(node)->asSequence();
	}
}

mapping uml::Class::fillClass(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Class).map toClassInClass(node)->asSequence();
	}
}

mapping uml::Component::fillClass(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Class).map toClassInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillClass(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Class).map toClassInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInClass(node)->asSequence();
	}
}

mapping uml::Component::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInInterface(node)->asSequence();
	}
}

mapping uml::PrimitiveType::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInPrimitiveType(node)->asSequence();
	}
}

mapping uml::DataType::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInDataType(node)->asSequence();
	}
}

mapping uml::RedefinableTemplateSignature::fillConnectableElementTemplateParameter(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='TemplateParameterCompartment';
}{
	init {
		result := self.parameter->selectByKind(ConnectableElementTemplateParameter).map toConnectableElementTemplateParameterInRedefinableTemplateSignature(node)->asSequence();
	}
}

mapping uml::TemplateSignature::fillOperationTemplateParameter(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='TemplateParameterCompartment';
}{
	init {
		result := self.parameter->selectByKind(OperationTemplateParameter).map toOperationTemplateParameterInTemplateSignature(node)->asSequence();
	}
}

mapping uml::RedefinableTemplateSignature::fillClassifierTemplateParameter(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='TemplateParameterCompartment';
}{
	init {
		result := self.parameter->selectByKind(ClassifierTemplateParameter).map toClassifierTemplateParameterInRedefinableTemplateSignature(node)->asSequence();
	}
}

mapping uml::RedefinableTemplateSignature::fillTemplateParameter(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='TemplateParameterCompartment';
}{
	init {
		result := self.parameter->selectByKind(TemplateParameter).map toTemplateParameterInRedefinableTemplateSignature(node)->asSequence();
	}
}

mapping uml::Enumeration::fillEnumerationLiteral(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='EnumerationCompartment';
}{
	init {
		result := self.ownedLiteral->selectByKind(EnumerationLiteral).map toEnumerationLiteralInEnumeration(node)->asSequence();
	}
}

mapping uml::Class::fillReception(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedReception->selectByKind(Reception).map toReceptionInClass(node)->asSequence();
	}
}

mapping uml::Interface::fillReception(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedReception->selectByKind(Reception).map toReceptionInInterface(node)->asSequence();
	}
}

mapping uml::InstanceSpecification::fillSlot(node : ListCompartment) : Sequence(Node) when {
	node.type='SlotCompartment';
}{
	init {
		result := self.slot->selectByKind(Slot).map toSlotInInstanceSpecification(node)->asSequence();
	}
}

mapping uml::Class::fillInterface(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Interface).map toInterfaceInClass(node)->asSequence();
	}
}

mapping uml::Component::fillInterface(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Interface).map toInterfaceInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillInterface(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Interface).map toInterfaceInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillEnumeration(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Enumeration).map toEnumerationInClass(node)->asSequence();
	}
}

mapping uml::Component::fillEnumeration(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Enumeration).map toEnumerationInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillEnumeration(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Enumeration).map toEnumerationInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillPrimitiveType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(PrimitiveType).map toPrimitiveTypeInClass(node)->asSequence();
	}
}

mapping uml::Component::fillPrimitiveType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(PrimitiveType).map toPrimitiveTypeInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillPrimitiveType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(PrimitiveType).map toPrimitiveTypeInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillDataType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(DataType).map toDataTypeInClass(node)->asSequence();
	}
}

mapping uml::Component::fillDataType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(DataType).map toDataTypeInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillDataType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(DataType).map toDataTypeInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillSignal(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Signal).map toSignalInClass(node)->asSequence();
	}
}

mapping uml::Component::fillSignal(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Signal).map toSignalInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillSignal(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Signal).map toSignalInInterface(node)->asSequence();
	}
}

mapping Property::toPropertyInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3012';
}

mapping Property::toPropertyInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3002';
}

mapping Property::toPropertyInSignal(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3005';
}

mapping Property::toPropertyInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3006';
}

mapping Property::toPropertyInPrimitiveType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3041';
}

mapping Property::toPropertyInDataType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3018';
}

mapping Class::toClassInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3014';
}

mapping Class::toClassInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3004';
}

mapping Class::toClassInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3008';
}

mapping Operation::toOperationInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3013';
}

mapping Operation::toOperationInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3003';
}

mapping Operation::toOperationInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3007';
}

mapping Operation::toOperationInPrimitiveType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3042';
}

mapping Operation::toOperationInDataType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3019';
}

mapping ConnectableElementTemplateParameter::toConnectableElementTemplateParameterInRedefinableTemplateSignature(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3034';
}

mapping OperationTemplateParameter::toOperationTemplateParameterInTemplateSignature(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3035';
}

mapping ClassifierTemplateParameter::toClassifierTemplateParameterInRedefinableTemplateSignature(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3031';
}

mapping TemplateParameter::toTemplateParameterInRedefinableTemplateSignature(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3016';
}

mapping EnumerationLiteral::toEnumerationLiteralInEnumeration(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3017';
}

mapping Reception::toReceptionInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3011';
}

mapping Reception::toReceptionInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3039';
}

mapping Slot::toSlotInInstanceSpecification(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3030';
}

mapping Interface::toInterfaceInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3036';
}

mapping Interface::toInterfaceInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3037';
}

mapping Interface::toInterfaceInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3038';
}

mapping Enumeration::toEnumerationInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3052';
}

mapping Enumeration::toEnumerationInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3053';
}

mapping Enumeration::toEnumerationInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3054';
}

mapping PrimitiveType::toPrimitiveTypeInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3047';
}

mapping PrimitiveType::toPrimitiveTypeInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3046';
}

mapping PrimitiveType::toPrimitiveTypeInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3048';
}

mapping DataType::toDataTypeInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3044';
}

mapping DataType::toDataTypeInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3045';
}

mapping DataType::toDataTypeInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3043';
}

mapping Signal::toSignalInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3050';
}

mapping Signal::toSignalInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3051';
}

mapping Signal::toSignalInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3049';
}



/******* Edges ********/


mapping UMLConnector::toPapyrusConnector() : Connector inherits Connector::toPapyrusConnector when {
	self.type = '' and (
		/*self.element.oclIsTypeOf(AssociationClass)or*/
		self.element.oclIsTypeOf(Association)or
		self.element.oclIsTypeOf(Association)or
		self.element.oclIsTypeOf(InterfaceRealization)or
		self.element.oclIsTypeOf(Substitution)or
		self.element.oclIsTypeOf(Realization)or
		self.element.oclIsTypeOf(Abstraction)or
		self.element.oclIsTypeOf(Usage)or
		self.element.oclIsTypeOf(Dependency)or
		self.element.oclIsTypeOf(Dependency)or
		self.element.oclIsTypeOf(ElementImport)or
		self.element.oclIsTypeOf(PackageImport)or
		self.element.oclIsTypeOf(PackageMerge)or
		self.element.oclIsTypeOf(ProfileApplication)or
		self.element.oclIsTypeOf(TemplateBinding)or
		self.element.oclIsTypeOf(GeneralizationSet)or
		self.element.oclIsTypeOf(InstanceSpecification)or
		self.element.oclIsTypeOf(InformationFlow)
		
	)
}{
	result.styles := self.map toFontStyle();
}

mapping UMLConnector::toGeneralizationConnector() : Connector inherits Connector::toPapyrusConnector when {
	self.type='' and self.element.oclIsTypeOf(Generalization)
}{
	result.children->forEach(element){
		element.type:='6007'
	};
	result.styles := self.map toFontStyle();
	result.sourceAnchor := object IdentityAnchor{};
	result.targetAnchor := object IdentityAnchor{};
	
}

mapping UMLConnector::toCommentLink() : Connector inherits Connector::toCommentLink when{
	self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Comment) or 
	 	self.target.element.oclIsKindOf(Comment)
	)
}{
	result.type :='4013';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
}

mapping UMLConnector::toConstraintLink() : Connector inherits Connector::toPapyrusConnector when{
	self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Constraint) or 
	 	self.target.element.oclIsKindOf(Constraint)
	)
}{	
	result.type :='4014';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
}


/* Context Links are not supported in RSA Class Diagrams */
/*
mapping UMLConnector::toContextLink() : Connector inherits Connector::toPapyrusConnector when{
		self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Constraint) or 
	 	self.target.element.oclIsKindOf(Constraint)
	)
}{	
	result.type :='8500';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
	result.children += object DecorationNode {
		type := '8501';
		layoutConstraint := object Location {
			y := 15;
		}
	}
}
*/

/****** Element Type queries ******/

query View::getNodeType(element : Element) : String {
	return
		if element.oclIsTypeOf(Dependency) then '2014' 
		elif element.oclIsTypeOf(AssociationClass) then '2013' 
		elif element.oclIsTypeOf(Association) then '2015' 
		elif element.oclIsTypeOf(InstanceSpecification) then '2001' 
		elif element.oclIsTypeOf(Component) then '2002' 
		elif element.oclIsTypeOf(Signal) then '2003' 
		elif element.oclIsTypeOf(Interface) then '2004' 
		elif element.oclIsTypeOf(Model) then '2005' 
		elif element.oclIsTypeOf(Enumeration) then '2006' 
		elif element.oclIsTypeOf(Package) then '2007' 
		elif element.oclIsTypeOf(InformationItem) then '2099' 
		elif element.oclIsTypeOf(Class) then '2008' 
		elif element.oclIsTypeOf(PrimitiveType) then '2009' 
		elif element.oclIsTypeOf(DataType) then '2010' 
		elif element.oclIsTypeOf(Constraint) then '2011' 
		elif element.oclIsTypeOf(Comment) then '2012' 
		elif element.oclIsTypeOf(Diagram) then '2016' 
		elif element.oclIsTypeOf(DurationObservation) then '2095' 
		elif element.oclIsTypeOf(TimeObservation) then '2096' 
		elif element.oclIsKindOf(NamedElement) then '2097'
		else self.fail()
	endif;
}


query View::getDecorationType(element : Element) : String{
	var res := self.doGetDecorationType(element);

	/*log('Get papyrus ID for'+ element.oclAsType(EObject).eClass().name+', '+self.type);
	
	log(res);
	
	if self.container().oclIsKindOf(Node) then 
		log('IsNode')
	else 
		log('IsEdge')
	endif;*/
	
	return res;	
}

query View::doGetDecorationType(element : Element) : String{
	
	return if self.container().oclIsKindOf(Node) then {
		return if element.oclIsKindOf(AssociationClass) then
			return switch {
				case (self.type = 'Name') '5066';
				case (self.type = 'AttributeCompartment') '7034';
				case (self.type = 'OperationCompartment') '7036';
				case (self.type = 'SignalCompartment') '7037';
			}
		elif element.oclIsKindOf(InstanceSpecification) then
			return switch {
				case (self.type = 'Name') '5002';
				case (self.type = 'SlotCompartment') '7001';
			}
		elif element.oclIsKindOf(Component) then
			return switch {
				case (self.type = 'Name') '5005';
				case (self.type = 'AttributeCompartment') '7002';
			case (self.type = 'OperationCompartment') '7003';
			case (self.type = 'SignalCompartment') '7004';
			}
		elif element.oclIsKindOf(Signal) then
			return switch {
				case (self.type = 'Name') '5008';
				case (self.type = 'AttributeCompartment') '7005';
			}
		elif element.oclIsKindOf(Interface) then
			return switch {
				case (self.type = 'Name') '5011';
				case (self.type = 'AttributeCompartment') '7006';
				case (self.type = 'OperationCompartment') '7007';
				case (self.type = 'SignalCompartment') '7008';
			}
		elif element.oclIsKindOf(Model) then
			return switch {
				case (self.type = 'Name') '5020';
				case (self.type = 'PackageContents') '7009';
			}
		elif element.oclIsKindOf(Enumeration) then
			return switch {
				case (self.type = 'Name') '5023';
				case (self.type = 'EnumerationCompartment') '7015';
			}
		elif element.oclIsKindOf(Package) then
			return switch {
				case (self.type = 'Name') '5026';
				case (self.type = 'PackageContents') '7016';
			}
		elif element.oclIsKindOf(InformationItem) then
			return switch {
				case (self.type = 'Name') '5161';
				
			}
		elif element.oclIsKindOf(Class) then
			return switch {
				case (self.type = 'Name') '5029';
				case (self.type = 'AttributeCompartment') '7017';
				case (self.type = 'OperationCompartment') '7018';
				case (self.type = 'SignalCompartment') '7019';
			}
		elif element.oclIsKindOf(PrimitiveType) then
			return switch {
				case (self.type = 'Name') '5032';
				case (self.type = 'AttributeCompartment') '7039';
				case (self.type = 'OperationCompartment') '7040';
			}
		elif element.oclIsKindOf(DataType) then
			return switch {
				case (self.type = 'Name') '5035';
				case (self.type = 'AttributeCompartment') '7020';
				case (self.type = 'OperationCompartment') '7021';
			}
		elif element.oclIsKindOf(Constraint) then
			return switch {
				case (self.type = 'Name') '5037';
				
			}
		elif element.oclIsKindOf(Diagram) then
			return switch {
				case (self.type = 'Name') '0';
				
			}
		elif element.oclIsKindOf(DurationObservation) then
			return switch {
				case (self.type = 'Name') '5155';
				
			}
		elif element.oclIsKindOf(TimeObservation) then
			return switch {
				case (self.type = 'Name') '5153';
				
			}
		elif element.oclIsKindOf(NamedElement) then
			return switch {
				case (self.type = 'Name') '5157';
			}
		endif
	} else {
		return if element.oclIsKindOf(Association) then
			return switch {
				case (self.type='Name') '6002';		
				case (self.type = 'KindLabel') '6001';
				case (self.type = 'NameLabel') '6002';
			}
		elif element.oclIsKindOf(Property) then 
			return if element.oclAsType(Property).association.oclIsTypeOf(Association) then
				return switch {
					case (self.type = 'ToRoleLabel') '6003';
				
					case (self.type = 'FromRoleLabel') '6005';
					
					case (self.type = 'FromMultiplicityLabel') '6033';
					
					case (self.type = 'ToMultiplicityLabel') '6034';
				}
			elif element.oclAsType(Property).association.oclIsTypeOf(AssociationClass) then
				return switch {
					case (self.type = 'ToRoleLabel') '6032';
					case (self.type = 'FromRoleLabel') '6031';
				}
			endif
		elif element.oclIsKindOf(Generalization) then
			return switch {
						
				case (self.type = 'KindLabel') '6007';
			}
		
		elif element.oclIsKindOf(InterfaceRealization) then
			return switch {
				case (self.type='Name') '6009';		
				case (self.type = 'KindLabel') '6008';
				case (self.type = 'NameLabel') '6009';
			}
		
		elif element.oclIsKindOf(Substitution) then
			return switch {
				case (self.type='Name') '6011';		
				case (self.type = 'KindLabel') '6010';
				case (self.type = 'NameLabel') '6011';
			}
		
		elif element.oclIsKindOf(Realization) then
			return switch {
				case (self.type='Name') '6013';		
				case (self.type = 'KindLabel') '6012';
				case (self.type = 'NameLabel') '6013';
			}
		
		elif element.oclIsKindOf(Abstraction) then
			return switch {
				case (self.type='Name') '6014';		
				case (self.type = 'NameLabel') '6014';
				case (self.type = 'KindLabel') '6015';
			}
		
		elif element.oclIsKindOf(Usage) then
			return switch {
				case (self.type='Name') '6016';		
				case (self.type = 'NameLabel') '6016';
				case (self.type = 'KindLabel') '6017';
			}
		
		elif element.oclIsKindOf(Dependency) then
			return switch {
				case (self.type='Name') '6026';		
				case (self.type = 'NameLabel') '6026';
				case (self.type = 'KindLabel') '6027';
			}

		elif element.oclIsKindOf(ElementImport) then
			return switch {
						
				
				case (self.type = 'KindLabel') '6021';
			}
		
		elif element.oclIsKindOf(PackageImport) then
			return switch {
						
				case (self.type = 'KindLabel') '6022';
			}
		
		elif element.oclIsKindOf(PackageMerge) then
			return switch {
						
				case (self.type = 'KindLabel') '6030';
			}
		
		elif element.oclIsKindOf(TemplateBinding) then
			return switch {
						
				
				case (self.type = 'KindLabel') '6036';
			}
		
		elif element.oclIsKindOf(GeneralizationSet) then
			return switch {
						
				
				case (self.type = 'KindLabel') '6037';
			}

		elif element.oclIsKindOf(InformationFlow) then
			return switch {
						
				
				case (self.type = 'KindLabel') '6041';
			}		
		endif;
	} endif;
}


query View::getEdgeType(element : Element) : String {
	return if self.type = 'Reference' then '' /* Context and Constraint Links handled separately */
		elif element.oclIsTypeOf(AssociationClass) then '4017'
		elif element.oclIsTypeOf(Association) then '4001'
		elif element.oclIsTypeOf(Association) then '4019'
		elif element.oclIsTypeOf(Generalization) then '4002'
		elif element.oclIsTypeOf(InterfaceRealization) then '4003'
		elif element.oclIsTypeOf(Substitution) then '4004'
		elif element.oclIsTypeOf(Realization) then '4005'
		elif element.oclIsTypeOf(Abstraction) then '4006'
		elif element.oclIsTypeOf(Usage) then '4007'
		elif element.oclIsTypeOf(Dependency) then '4008'
		elif element.oclIsTypeOf(Dependency) then '4018'
		elif element.oclIsTypeOf(ElementImport) then '4009'
		elif element.oclIsTypeOf(PackageImport) then '4010'
		elif element.oclIsTypeOf(PackageMerge) then '4011'
		elif element.oclIsTypeOf(ProfileApplication) then '4012'
		elif element.oclIsTypeOf(Comment) then'4013'
		elif element.oclIsTypeOf(TemplateBinding) then '4015'
		elif element.oclIsTypeOf(GeneralizationSet) then '4020'
		elif element.oclIsTypeOf(InstanceSpecification) then '4021'
		elif element.oclIsTypeOf(InformationFlow) then '4026'
		else self.fail()
	endif;
}

