/**
 * Copyright (c) 2014 CEA LIST.
 *  
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 * Contributors:
 *  CEA LIST - Initial API and implementation
 */
import UmlUtilities;

modeltype DC uses "http://www.omg.org/spec/DD/20110901/DC";
modeltype DG uses "http://www.omg.org/spec/DD/20110901/DG";
modeltype DI uses "http://www.omg.org/spec/DD/20110901/DI";
modeltype UMLDI uses "http://www.omg.org/spec/UML/20131001/UMLDI";
modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";

library UmlShapes;

mapping UML::AcceptEventAction::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement { 
	init {
		var b := shape.bounds;
		if self.trigger->size() = 1 and self.trigger->any(true).event.oclIsKindOf(UML::TimeEvent) then
			result := object DG::Polygon {
				point += object DC::Point { x:=b.x; y:=b.y; };
				point += object DC::Point { x:=b.x+b.width; y:=b.y+b.height; };
				point += object DC::Point { x:=b.x; y:=b.y+b.height; };
				point += object DC::Point { x:=b.x+b.width; y:=b.y; };
			}
		else
			result := object DG::Polygon {
				point += object DC::Point { x:=b.x; y:=b.y; };
				point += object DC::Point { x:=b.x+b.width; y:=b.y; };
				point += object DC::Point { x:=b.x+b.width; y:=b.y+b.height; };
				point += object DC::Point { x:=b.x; y:=b.y+b.height; };
				point += object DC::Point { x:=b.x+20; y:=b.y+b.height/2; };
			}
		endif;
	}
}

mapping UML::Activity::shapeToSpecialNotation(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		if shape.owningUmlDiagramElement.oclIsKindOf(ActivityDiagram) then
			result := shapeToFrame(shape)
		else
			result := object DG::Rectangle {
				bounds := shape.bounds.clone().oclAsType(DC::Bounds);
				cornerRadius := 10;
			}
		endif;
	}
}

mapping UML::ActivityFinalNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := filledCircleWithBorder(shape); 
	}
}

mapping UML::ActivityPartition::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		if self.isDimension and shape.oclAsType(UMLDI::ActivityPartitionShape).subpartitionCompartment->notEmpty() then
			result := object DG::Group {}
		else
			result := rectangle(shape)
		endif;
	}
}

mapping UML::Actor::shapeToSpecialNotation(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		var sx := b.width/1;
		var sy := b.height/2;
		var s := min(sx, sy);
		var t := Tuple {x=b.x+b.width/2-(s*1)/2, y=b.y+b.height/2-(s*2)/2, width=s*1, height=s*2};
		result := object DG::Group {
			member += object DG::Circle {
				radius := 0.125*t.height;
				center := object DC::Point { x:= t.x+0.5*t.width; y:= t.y+0.125*t.height; };
			};
			member += object DG::Line {
				start := object DC::Point { x:= t.x; y:= t.y+0.4*t.height; };
				_end := object DC::Point { x:= t.x+t.width; y:= t.y+0.4*t.height; };
			};
			member += object DG::Line {
				start := object DC::Point { x:= t.x+t.width/2; y:= t.y+0.25*t.height; };
				_end := object DC::Point { x:= t.x+t.width/2; y:= t.y+0.6*t.height; };
			};
			member += object DG::Polyline {
				point += object DC::Point { x:= t.x; y:= t.y+t.height; };
				point += object DC::Point { x:= t.x+t.width/2; y:= t.y+0.6*t.height; };
				point += object DC::Point { x:= t.x+t.width; y:= t.y+t.height; };
			};
		}
	}
}

mapping UML::Association::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b = shape.bounds;
		result := object DG::Polygon {
			point += object DC::Point { x:= b.x; y := b.y + b.height/2; };
			point += object DC::Point { x:= b.x + b.width/2; y := b.y; };
			point += object DC::Point { x:= b.x + b.width; y := b.y + b.height/2; };
			point += object DC::Point { x:= b.x + b.width/2; y := b.y + b.height; };
		}
	}
}

mapping UML::CallBehaviorAction::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement { 
	init {
		var b := shape.bounds;
		result := object DG::Group { 
			member += object DG::Rectangle {
				bounds := b.clone().oclAsType(DC::Bounds);
				cornerRadius := 10;
			};
			member += object DG::Path {
				command += object DG::MoveTo { point := object DC::Point { x := b.x+b.width-20; y := b.y+b.height-5; } };
				command += object DG::LineTo { point := object DC::Point { x := b.x+b.width-20; y := b.y+b.height-10; } };
				command += object DG::LineTo { point := object DC::Point { x := b.x+b.width-10; y := b.y+b.height-10; } };
				command += object DG::LineTo { point := object DC::Point { x := b.x+b.width-10; y := b.y+b.height-5; } };
				command += object DG::MoveTo { point := object DC::Point { x := b.x+b.width-15; y := b.y+b.height-14; } };
				command += object DG::LineTo { point := object DC::Point { x := b.x+b.width-15; y := b.y+b.height-5; } };
			};
		}
	}
}

mapping UML::Class::shapeToDefaultNotation(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		if self.isActive then
			result := object DG::Group {
				member += rectangle(shape);
				var border := rectangle(shape);
				border.bounds.x :=shape.bounds.x+5;
				border.bounds.width :=shape.bounds.width-10;
				member += border;
			}
		else
			result := rectangle(shape)
		endif;
	}
}

mapping UML::Classifier::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		if (shape.oclAsType(UMLDI::ClassifierShape).useClassifierNotation) then
			result := self.map shapeToDefaultNotation(shape)
		else
			result := self.map shapeToSpecialNotation(shape)
		endif;
	}
}

mapping UML::Classifier::shapeToDefaultNotation(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := rectangle(shape);
	}
}

mapping UML::Classifier::shapeToSpecialNotation(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := rectangle(shape);
	}
}

helper shapeToFrame(shape : UMLDI::UmlShape) : DG::Group {
	var b := shape.bounds; 
	return object DG::Group {
		member += object DG::Rectangle { 
			bounds := b.clone().oclAsType(DC::Bounds);
		};
		if shape.mainLabel->notEmpty() then {
			var nb := shape.mainLabel.bounds;
			member += object DG::Polyline {
				point += object DC::Point { x:=nb.x+nb.width+7; y:=b.y; }; 
				point += object DC::Point { x:=nb.x+nb.width+7; y:=nb.y+nb.height/2; }; 
				point += object DC::Point { x:=nb.x+nb.width; y:=nb.y+nb.height; }; 
				point += object DC::Point { x:=b.x; y:=nb.y+nb.height; }; 
			}
		} endif;
	};
}

mapping UML::CombinedFragment::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		if self.interactionOperator = UML::InteractionOperatorKind::par and
			shape.owningUmlDiagramElement.umlModelElement.oclIsKindOf(UML::Lifeline) then
			result := object DG::Group {
				member += object DG::Polyline {
					point += object DC::Point { x:=b.x; y:=b.y+10; };
					point += object DC::Point { x:=b.x; y:=b.y; };
					point += object DC::Point { x:=b.x+b.width; y:=b.y; };
					point += object DC::Point { x:=b.x+b.width; y:=b.y+10; };
				};
				member += object DG::Polyline {
					point += object DC::Point { x:=b.x; y:=b.y+b.height-10; };
					point += object DC::Point { x:=b.x; y:=b.y+b.height; };
					point += object DC::Point { x:=b.x+b.width; y:=b.y+b.height; };
					point += object DC::Point { x:=b.x+b.width; y:=b.y+b.height-10; };
				};
			}
		else
			result := shapeToFrame(shape)
		endif;
		result.style := object DG::Style { fill := null };
	}
}

mapping UML::Comment::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := createNoteShape(shape);
	}
}

mapping UML::ConnectionPointReference::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := if self.entry->notEmpty() then
			circle(shape)
		else if self.exit->notEmpty() then
			circleWithX(shape)
		endif endif;		
	}
}

mapping UML::Constraint::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := createNoteShape(shape);
	}
}

mapping UML::Continuation::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		result := object DG::Rectangle {
			bounds := shape.bounds.clone().oclAsType(DC::Bounds);
			cornerRadius := b.height/2;
			style := object DG::Style { fill:=null; };
		}
	}
}

mapping UML::DecisionNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := diamond(shape);
	}
}

mapping UML::Dependency::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b = shape.bounds;
		result := object DG::Circle {
			center := object DC::Point { x:= b.x + b.width/2; y := b.y + b.height/2; };
			radius := min(b.width, b.height);
			_class := 'filled';
		}
	}
}

mapping UML::DestructionOccurrenceSpecification::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		result := object DG::Group {
			member += object DG::Line {
				start := object DC::Point { x:=b.x; y:=b.y };
				_end := object DC::Point { x:=b.x+b.width; y:=b.y+b.height };
			};
			member += object DG::Line {
				start := object DC::Point { x:=b.x; y:=b.y+b.height };
				_end := object DC::Point { x:=b.x+b.width; y:=b.y };
			};
		}
	}
}

mapping UML::DurationConstraint::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		if shape.diagram.oclIsKindOf(UMLDI::TimingDiagram) then
			result := object DG::Group {
				member += object DG::Line {
					start := object DC::Point{ x:=b.x; y:=b.y; };
					_end := object DC::Point{ x:=b.x; y:=b.y+b.height; };
				};
				member += object DG::Line {
					start := object DC::Point{ x:=b.x+b.width; y:=b.y; };
					_end := object DC::Point{ x:=b.x+b.width; y:=b.y+b.height; };
				};
				member += object DG::Line {
					start := object DC::Point{ x:=b.x; y:=b.y+b.height/2; };
					_end := object DC::Point{ x:=b.x+b.width; y:=b.y+b.height/2; };
					startMarker := shape.resolveDefinitions().getMarker("startOpenArrow");		
					endMarker := shape.resolveDefinitions().getMarker("endOpenArrow");		
				};
			}
		else
			result := object DG::Group {
				member += object DG::Line {
					start := object DC::Point{ x:=b.x; y:=b.y; };
					_end := object DC::Point{ x:=b.x+b.width; y:=b.y; };
				};
				member += object DG::Line {
					start := object DC::Point{ x:=b.x; y:=b.y+b.height; };
					_end := object DC::Point{ x:=b.x+b.width; y:=b.y+b.height; };
				};
				member += object DG::Line {
					start := object DC::Point{ x:=b.x+b.width/2; y:=b.y; };
					_end := object DC::Point{ x:=b.x+b.width/2; y:=b.y+b.height; };
					startMarker := shape.resolveDefinitions().getMarker("startOpenArrow");		
					endMarker := shape.resolveDefinitions().getMarker("endOpenArrow");		
				};
			}
		endif;
	}
}

mapping UML::Element::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := rectangle(shape);
	}
}

helper rectangle(shape : DI::Shape) : DG::Rectangle {
	return object DG::Rectangle {
		bounds := shape.bounds.clone().oclAsType(DC::Bounds);
	};
}

mapping UML::ExecutableNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement { 
	init {
		result := object DG::Rectangle {
			bounds := shape.bounds.clone().oclAsType(DC::Bounds);
			cornerRadius := 10;
		}
	}
}

mapping UML::ExpansionNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		result := object DG::Group {	
			member += rectangle(shape);
			member += object DG::Line { 
				start := object DC::Point { x:=b.x+b.width * 0.25; y:=b.y; };
				_end := object DC::Point { x:=b.x+b.width * 0.25; y:=b.y+b.height; };
			};
			member += object DG::Line { 
				start := object DC::Point { x:=b.x+b.width * 0.5; y:=b.y; };
				_end := object DC::Point { x:=b.x+b.width * 0.5; y:=b.y+b.height; };
			};
			member += object DG::Line { 
				start := object DC::Point { x:=b.x+b.width * 0.75; y:=b.y; };
				_end := object DC::Point { x:=b.x+b.width * 0.75; y:=b.y+b.height; };
			};
		};
	}
}

mapping UML::FinalState::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := filledCircleWithBorder(shape); 
	}
}

mapping UML::ForkNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := filledBar(shape);
	}
}

helper filledCircleWithBorder(shape : UMLDI::UmlShape) : DG::Group {
	var b = shape.bounds;
	return object DG::Group { 
		member += object DG::Circle {
			center := object DC::Point { x:= b.x + b.width/2; y := b.y + b.height/2; };
			radius := min(b.width/2, b.height/2);
		};
		member += object DG::Circle {
			center := object DC::Point { x:= b.x + b.width/2; y := b.y + b.height/2; };
			radius := min(b.width/2, b.height/2) - 3;
			_class := "filled";
		};
	};
}

mapping UML::FlowFinalNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := circleWithX(shape);
	}
}
	
mapping UML::InitialNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := filledCircle(shape);
	}
}

mapping UML::InputPin::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		if shape.targetEdge->isEmpty() then {
			var bp := shape.bounds;
			var ba := shape.owningDiagramElement.oclAsType(DI::Shape).bounds;
			var dx := (bp.x+bp.width/2) - (ba.x+ba.width/2);
			var dy := (bp.y+bp.height/2) - (ba.y+ba.height/2);
			result := object DG::Group {
				member += rectangle(shape);
				member += object DG::Path {
					command += object DG::MoveTo { point := object DC::Point { x := bp.x; y := bp.y+bp.height/2; } };
					command += object DG::LineTo { point := object DC::Point { x := bp.x+bp.width; y := bp.y+bp.height/2; } };
					endMarker := shape.resolveDefinitions().getMarker("endOpenArrowSmall");
					transform := object DG::Rotate {
						center := object DC::Point { x := bp.x+bp.width/2; y := bp.y+bp.height/2; };
						if dx>=0 and dx>ba.width/2 then
							angle := 180
						else if dx<=0 and abs(dx)>ba.width/2 then
							angle := 0
						else if dy>=0 and dy>ba.height/2 then
							angle := -90
						else if dy<=0 and abs(dy)>ba.height/2 then
							angle := 90
						endif endif endif endif;
					};	
				}
			}
		} else
			result := rectangle(shape)
		endif;
	}
}

mapping UML::Interaction::shapeToSpecialNotation(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		if shape.diagram.oclIsKindOf(UMLDI::TimingDiagram) then {
			result := object DG::Group {
				member += shapeToFrame(shape);
				member += self.shapeToFrameRuler(shape);
			}
		} else {
			result := shapeToFrame(shape)
		} endif;
	}
}

helper UML::Interaction::shapeToFrameRuler(shape : UMLDI::UmlShape) : DG::Group {
	var x1 : Real := shape.oclAsType(UMLDI::InteractionShape).subfragmentCompartment.topUmlDiagramElement[UMLDI::LifelineShape]->
		select(subfragmentShape->notEmpty())->first().subfragmentShape->at(1).bounds.x;		
	var x2 := shape.bounds.x + shape.bounds.width;
	var y2 := shape.bounds.y + shape.bounds.height;
	var n := 10;
	var j := (x2-x1)/n; 
	return object DG::Group {
		member += List{0..n-1}->collect(i|
			object DG::Group {
				member += object DG::Line {
					start := object DC::Point { x:=x1+i*j; y:=y2-5 };
					_end := object DC::Point { x:=x1+i*j; y:=y2+5 };
				};
				member += object DG::Text {
					data := (i+1).toString();
					bounds := object DC::Bounds { x:= x1+i*j; y:=y2+10; };
					anchor := DG::TextAnchor::middle;
				}
			}
		);
		style := object DG::Style { fontSize := 11; }
	};
}

mapping UML::InteractionOperand::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		if self.container().oclAsType(UML::CombinedFragment).operand->indexOf(self) > 1 then
			result := object DG::Line {
				start := object DC::Point { x := b.x; y := b.y; };
				_end := object DC::Point { x := b.x + b.width; y := b.y; };
				_class := "dashed";
			}
		else
			result := object DG::Group {}
		endif;
	}
}

mapping UML::InteractionUse::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := shapeToFrame(shape);
	}
}

mapping UML::Interface::shapeToSpecialNotation(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var r := min(shape.bounds.width, shape.bounds.height)/2;
		if shape.targetUmlEdge[UMLDI::UsageEdge]->size() = 1 then {
			var edge = shape.targetUmlEdge![UMLDI::UsageEdge];
			var p1 := edge.waypoint->at(edge.waypoint->size()-1);
			var p2 := edge.waypoint->at(edge.waypoint->size());
			result := object DG::Path {
				command += object DG::MoveTo {
					point := object DC::Point {
						x := shape.bounds.x+shape.bounds.width/2;
						y := shape.bounds.y;
					}
				};
				command += object DG::EllipticalArcTo { 
					radii := object DC::Dimension {
						width := r;
						height := r;
					};
					point := object DC::Point { 
						x := shape.bounds.x+shape.bounds.width/2;
						y := shape.bounds.y+shape.bounds.height;
					};
				};
				transform := object DG::Rotate {
					angle := getAngle(p1.x, p1.y, p2.x, p2.y);
					center := object DC::Point {
						x := shape.bounds.x+shape.bounds.width/2;
						y := shape.bounds.y+shape.bounds.height/2;
					};
				}
			}
		} else {
			result := object DG::Circle {
				center := object DC::Point { 
					x := shape.bounds.x + shape.bounds.width/2; 
					y := shape.bounds.y + shape.bounds.height/2;
				};
				radius := r;
			}
		}
		endif;
	}
}

mapping UML::InterruptibleActivityRegion::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := rectangle(shape);
		result._class := "dashed";
	}
}

mapping UML::JoinNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := filledBar(shape);
	}
}

mapping UML::Lifeline::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var diagram = shape.diagram;
		if diagram.oclIsKindOf(UMLDI::SequenceDiagram) then {
			var sb = shape.bounds;
			var lb = shape.mainLabel.bounds;
			result := object DG::Group {
				member += object DG::Rectangle {
					bounds := object Bounds { x:=sb.x; y:=sb.y; width:=sb.width; height:=lb.height+2*(lb.y-sb.y) } 
				};
				if shape.oclAsType(UMLDI::LifelineShape).nestedLifelineShape->isEmpty() then
					member += object DG::Line {
						start := object DC::Point { x:=sb.x+sb.width/2; y:=sb.y+lb.height+2*(lb.y-sb.y) };
						_end := object DC::Point { x:=sb.x+sb.width/2; y:=sb.y+sb.height };
						_class := "dashed";
					}
				endif;
			}
		} else {
			result := rectangle(shape);
		} endif;
	}
}

mapping UML::MergeNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := diamond(shape);
	}
}

mapping UML::Model::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds; 
		var nb := shape.mainLabel.bounds;
		var dx := nb.x-b.x;
		var dy := nb.y-b.y;
		var compartment := shape.ownedUmlDiagramElement[UMLDI::UmlCompartment]->reject(
			oclIsKindOf(UMLDI::TemplateParameterCompartment))->sortedBy(bounds.y)->first();
		var cy := if compartment->notEmpty() then compartment.bounds.y else nb.y+nb.height+dy endif;
		result := object DG::Group {
			member += object DG::Rectangle { 
				bounds := object DC::Bounds { x:=b.x; y:=cy; width:=b.width; height:=b.height-cy+b.y };
			};
			member += object DG::Rectangle { 
				bounds := object DC::Bounds { x:=b.x; y:=b.y; width:=min(nb.width+2*dx+16, b.width); height:=cy-b.y };
			};
			member += object DG::Path {
				command += object DG::MoveTo { point := object DC::Point { x := nb.x+nb.width+dx+5; y := b.y+5; } };
				command += object DG::LineTo { point := object DC::Point { x := nb.x+nb.width+dx+0; y := b.y+13; } };
				command += object DG::LineTo { point := object DC::Point { x := nb.x+nb.width+dx+10; y := b.y+13; } };
				command += object DG::LineTo { point := object DC::Point { x := nb.x+nb.width+dx+5; y := b.y+5; } };
			};
		};
	}
}

mapping UML::Node::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var s := shape.bounds;
		var l := shape.mainLabel.bounds;
		var c := shape.ownedUmlDiagramElement[DI::Shape].bounds->iterate(b; 
			t : Tuple(x:Real, y:Real, width:Real, height:Real) = Tuple{x=l.x, y=l.y, width=l.width, height=l.height} | 
			Tuple{x=min(b.x, t.x), y=min(b.y, t.y), width=max(b.x+b.width, t.x+t.width)-min(b.x, t.x), height=max(b.y+b.height, t.y+t.height)-min(b.y, t.y)});
		var dx = s.width - c.width;	
		var dy = s.height - c.height;	
		result := object DG::Group {
			member += object DG::Rectangle {
				bounds := object DC::Bounds {x:=c.x; y:=c.y; width:=c.width; height:=c.height};
			};
			member += object DG::Line {
				start := object DC::Point {x:=c.x; y:=c.y};
				_end := object DC::Point {x:=c.x+dx; y:=c.y-dy};
			};
			member += object DG::Line {
				start := object DC::Point {x:=c.x+c.width; y:=c.y}; 
				_end := object DC::Point {x:=c.x+c.width+dx; y:=c.y-dy};
			};
			member += object DG::Line {
				start := object DC::Point {x:=c.x+c.width; y:=c.y+c.height}; 
				_end := object DC::Point {x:=c.x+c.width+dx; y:=c.y+c.height-dy};
			};
			member += object DG::Polyline {
				point += object DC::Point {x:=c.x+dx; y:=c.y-dy}; 
				point += object DC::Point {x:=c.x+c.width+dx; y:=c.y-dy};
				point += object DC::Point {x:=c.x+c.width+dx; y:=c.y+c.height-dy};
			};
		}
	}
}

mapping UML::ObjectNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		if self.type->notEmpty() and self.type.oclIsKindOf(UML::Signal) then {
			var b := shape.bounds;
			result := object DG::Polygon {
				point += object DC::Point { x:=b.x; y:=b.y; };
				point += object DC::Point { x:=b.x+b.width-15; y:=b.y; };
				point += object DC::Point { x:=b.x+b.width; y:=b.y+b.height/2; };
				point += object DC::Point { x:=b.x+b.width-15; y:=b.y+b.height; };
				point += object DC::Point { x:=b.x; y:=b.y+b.height; };
				point += object DC::Point { x:=b.x+15; y:=b.y+b.height/2; };
			}
		} else
			result := rectangle(shape)
		endif;
	} 
}

mapping UML::Observation::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := object DG::Group {}
	}
}

mapping UML::OutputPin::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		if shape.sourceEdge->isEmpty() then {
			var bp := shape.bounds;
			var ba := shape.owningDiagramElement.oclAsType(DI::Shape).bounds;
			var dx := (bp.x+bp.width/2) - (ba.x+ba.width/2);
			var dy := (bp.y+bp.height/2) - (ba.y+ba.height/2);
			result := object DG::Group {
				member += rectangle(shape);
				member += object DG::Path {
					command += object DG::MoveTo { point := object DC::Point { x := bp.x; y := bp.y+bp.height/2; } };
					command += object DG::LineTo { point := object DC::Point { x := bp.x+bp.width; y := bp.y+bp.height/2; } };
					endMarker := shape.resolveDefinitions().getMarker("endOpenArrowSmall");
					transform := object DG::Rotate {
						center := object DC::Point { x := bp.x+bp.width/2; y := bp.y+bp.height/2; };
						if dx>=0 and dx>ba.width/2 then
							angle := 0
						else if dx<=0 and abs(dx)>ba.width/2 then
							angle := 180
						else if dy>=0 and dy>ba.height/2 then
							angle := 90
						else if dy<=0 and abs(dy)>ba.height/2 then
							angle := -90
						endif endif endif endif;
					};	
				}
			}
		} else
			result := rectangle(shape)
		endif;
	}
}

mapping UML::Package::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds; 
		var nb := shape.mainLabel.bounds;
		var dx := nb.x-b.x;
		var dy := nb.y-b.y;
		var compartment := shape.ownedUmlDiagramElement[UMLDI::UmlCompartment]->reject(
			oclIsKindOf(UMLDI::TemplateParameterCompartment))->sortedBy(bounds.y)->first();
		var cy := if compartment->notEmpty() then compartment.bounds.y else nb.y+nb.height+dy endif;
		result := object DG::Group {
			member += object DG::Rectangle { 
				bounds := object DC::Bounds { x:=b.x; y:=cy; width:=b.width; height:=b.height-cy+b.y };
			};
			member += object DG::Rectangle { 
				bounds := object DC::Bounds { x:=b.x; y:=b.y; width:=nb.width+2*dx+1; height:=cy-b.y };
			};
		};
	}
}

mapping UML::Property::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
			var _property := shape.umlModelElement.oclAsType(UML::Property);
			result := object DG::Rectangle {
				bounds := shape.bounds.clone().oclAsType(DC::Bounds);
				if (_property.aggregation <> UML::AggregationKind::composite) {
					_class := "dashed";
				}
			}
	}
}

mapping UML::Pseudostate::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
			var pseudostate := shape.umlModelElement.oclAsType(UML::Pseudostate);
			result := switch {
				case (pseudostate.kind = UML::PseudostateKind::entryPoint) self.map shapeToEntryPointShape(shape);
				case (pseudostate.kind = UML::PseudostateKind::exitPoint) self.map shapeToExitPointShape(shape);
				case (pseudostate.kind = UML::PseudostateKind::initial) self.map shapeToInitialJunctionShape(shape);
				case (pseudostate.kind = UML::PseudostateKind::junction) self.map shapeToInitialJunctionShape(shape);
				case (pseudostate.kind = UML::PseudostateKind::join) self.map shapeToJoinShape(shape);
				case (pseudostate.kind = UML::PseudostateKind::fork) self.map shapeToForkShape(shape);
				case (pseudostate.kind = UML::PseudostateKind::choice) self.map shapeToChoiceShape(shape);
				case (pseudostate.kind = UML::PseudostateKind::terminate) self.map shapeToTerminateShape(shape);
				case (pseudostate.kind = UML::PseudostateKind::shallowHistory) self.map shapeToShallowHistoryShape(shape);
				case (pseudostate.kind = UML::PseudostateKind::deepHistory) self.map shapeToDeepHistoryShape(shape);
				else self.map shapeToPseudostateShape(shape);
			};
	}
}

mapping UML::Pseudostate::shapeToPseudostateShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := rectangle(shape);
	}
}

mapping UML::Pseudostate::shapeToEntryPointShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := circle(shape);
	}
}

helper circle(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	var b = shape.bounds;
	return object DG::Circle {
		center := object DC::Point { x:= b.x + b.width/2; y := b.y + b.height/2; };
		radius := min(b.width/2, b.height/2);
	}
}

mapping UML::Pseudostate::shapeToExitPointShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := circleWithX(shape);
	}
}
	
helper circleWithX(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	var b := shape.bounds;
	var cx := b.x + b.width/2;
	var cy := b.y + b.height/2;
	var r := min(b.width/2, b.height/2);
	return object DG::Group {
		member += object DG::Circle {
			center := object DC::Point { x:= cx; y := cy; };
			radius := r;
		};
		member += object DG::Line {
			start := object DC::Point { x:= cx + r * cos(45); y := cy + r * sin(45); };
			_end := object DC::Point { x:= cx + r * cos(-135); y := cy + r * sin(-135); };
		};
		member += object DG::Line {
			start := object DC::Point { x:= cx + r * cos(135); y := cy + r * sin(135); };
			_end := object DC::Point { x:= cx + r * cos(-45); y := cy + r * sin(-45); };
		};
	};
}

mapping UML::Pseudostate::shapeToInitialJunctionShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := filledCircle(shape);
	}
}

helper filledCircle(shape : UMLDI::UmlShape) : DG::Circle {
	var b = shape.bounds;
	return object DG::Circle {
		center := object DC::Point { x:= b.x + b.width/2; y := b.y + b.height/2; };
		radius := min(b.width/2, b.height/2);
		_class := "filled";
	}
}

mapping UML::Pseudostate::shapeToChoiceShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := diamond(shape);
	}
}

helper diamond(shape : UMLDI::UmlShape) : DG::Polygon {
	var b = shape.bounds;
	return object DG::Polygon {
		point += object DC::Point { x:= b.x; y := b.y + b.height/2; };
		point += object DC::Point { x:= b.x + b.width/2; y := b.y; };
		point += object DC::Point { x:= b.x + b.width; y := b.y + b.height/2; };
		point += object DC::Point { x:= b.x + b.width/2; y := b.y + b.height; };
	}
}

mapping UML::Pseudostate::shapeToJoinShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := filledBar(shape);
	}
}

mapping UML::Pseudostate::shapeToForkShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := filledBar(shape);
	}
}

helper filledBar(shape : UMLDI::UmlShape) : DG::Rectangle {
	return object DG::Rectangle {
		bounds := shape.bounds.clone().oclAsType(DC::Bounds);
		_class := "filled";
	}
}

mapping UML::Pseudostate::shapeToTerminateShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		var f := 0.8;
		result := object DG::Group {
			member += object DG::Line {
				start := object DC::Point { x:= b.x; y := b.y; };
				_end := object DC::Point { x:= b.x + b.width; y := b.y + b.height; };
			};
			member += object DG::Line {
				start := object DC::Point { x:= b.x + b.width; y := b.y; };
				_end := object DC::Point { x:= b.x; y := b.y + b.height; };
			};
			transform += object DG::Translate { deltaX := -(b.x+b.width/2)*(f-1); deltaY := -(b.y+b.height/2)*(f-1); };
			transform += object DG::Scale { factorX := f; factorY := f; };
		};
	}
}

mapping UML::Pseudostate::shapeToShallowHistoryShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := self.map shapeToHistoryShape(shape, "H");
	}
}

mapping UML::Pseudostate::shapeToDeepHistoryShape(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := self.map shapeToHistoryShape(shape, "H*");
	}
}

mapping UML::Pseudostate::shapeToHistoryShape(shape : UMLDI::UmlShape, s : String) : DG::GraphicalElement {
	init {
		var b = shape.bounds;
		result := object DG::Group {
			member += object DG::Circle {
				center := object DC::Point { x:= b.x + b.width/2; y := b.y + b.height/2; };
				radius := min(b.width/2, b.height/2);
			};
			member += object DG::Text {
				data := s;
				bounds := object DC::Bounds { x:=b.x+b.width/2; y:=b.y+b.height/4; };
				anchor := DG::TextAnchor::middle; 
			};
		};
	}
}

mapping UML::Region::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var placement = shape.oclAsType(UMLDI::RegionShape).placement;
		var b = shape.bounds;
		result := object DG::Group {
			_class := 'dashed';
			if (placement->includes(UMLDI::Placement::bottom)) {
				member += object Line {
					start := object DC::Point { x:=b.x; y:=b.y };
					_end := object DC::Point { x:=b.x+b.width; y:=b.y };
				};
			};
			if (placement->includes(UMLDI::Placement::left)) {
				member += object Line {
					start := object DC::Point { x:=b.x+b.width; y:=b.y };
					_end := object DC::Point { x:=b.x+b.width; y:=b.y+b.height };
				};
			};
			if (placement->includes(UMLDI::Placement::top)) {
				member += object Line {
					start := object DC::Point { x:=b.x; y:=b.y+b.height };
					_end := object DC::Point { x:=b.x+b.width; y:=b.y+b.height };
				};
			};
			if (placement->includes(UMLDI::Placement::right)) {
				member += object Line {
					start := object DC::Point { x:=b.x; y:=b.y };
					_end := object DC::Point { x:=b.x; y:=b.y+b.height };
				};
			}
		};
	}
}

mapping UML::SendSignalAction::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		result := object DG::Polygon {
			point += object DC::Point { x:=b.x; y:=b.y; };
			point += object DC::Point { x:=b.x+b.width-15; y:=b.y; };
			point += object DC::Point { x:=b.x+b.width; y:=b.y+b.height/2; };
			point += object DC::Point { x:=b.x+b.width-15; y:=b.y+b.height; };
			point += object DC::Point { x:=b.x; y:=b.y+b.height; };
		}
	} 
}

mapping UML::State::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		result := object DG::Group {
			member += object DG::Rectangle {
				bounds := shape.bounds.clone().oclAsType(DC::Bounds);
				cornerRadius := 10;
				if self.redefinedState->notEmpty() then
					_class := "dashed"
				endif;
			};
			if (self.region->notEmpty() or self.submachine->notEmpty()) and shape.oclAsType(StateShape).regionCompartment->isEmpty() then
				member += object DG::Group {
					member += object DG::Circle {
						center := object DC::Point{x:= b.x+b.width-10; y:=b.y+b.height-10}; radius := 5; 
					};
					member += object DG::Line {
						start := object DC::Point{x:= b.x+b.width-15; y:=b.y+b.height-10};
						_end := object DC::Point{x:= b.x+b.width-20; y:=b.y+b.height-10};
					};
					member += object DG::Circle {
						center := object DC::Point{x:= b.x+b.width-25; y:=b.y+b.height-10}; radius := 5; 
					};
				}
			endif;
		}
	}
}

mapping UML::StateInvariant::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		var b := shape.bounds;
		if shape.diagram.oclIsKindOf(SequenceDiagram) then
			if shape.oclAsType(UMLDI::StateInvariantShape).useStateShape then {
				result := object DG::Rectangle {
					bounds := shape.bounds.clone().oclAsType(DC::Bounds);
					cornerRadius := b.height/2;
				}
			} else {
				result := rectangle(shape);
				result.style := object DG::Style { stroke:=null };		
			} endif
		else if shape.diagram.oclIsKindOf(TimingDiagram) then {
			// find an adjacent State Invariant if any
			var lifeline := self.covered->any(true);
			var fragments := self.enclosingInteraction.fragment;
			var indexOfSI := fragments->indexOf(self);
			var nextSI := fragments->subOrderedSet(indexOfSI+1, fragments->size())->any(
				oclIsTypeOf(UML::StateInvariant) and covered->includes(lifeline)).oclAsType(UML::StateInvariant);
			var hasADestructionEvent := lifeline.coveredBy->exists(oclIsTypeOf(UML::DestructionOccurrenceSpecification));
				
			if shape.oclAsType(UMLDI::StateInvariantShape).useStateShape then {
				result := object DG::Polygon {
					point += object DC::Point { x:=b.x+10; y:=b.y; };
					point += object DC::Point { x:=b.x; y:=b.y+b.height/2; };
					point += object DC::Point { x:=b.x+10; y:=b.y+b.height; };
					if not hasADestructionEvent and nextSI = null then {
						point += object DC::Point { x:=b.x+b.width; y:=b.y+b.height; };
						point += object DC::Point { x:=b.x+b.width; y:=b.y; };
					} else {
						point += object DC::Point { x:=b.x+b.width-10; y:=b.y+b.height; };
						point += object DC::Point { x:=b.x+b.width; y:=b.y+b.height/2; };
						point += object DC::Point { x:=b.x+b.width-10; y:=b.y; };
					}endif;
				}
			} else {
				var group := object DG::Group {
					member += object DG::Line {
						start := object DC::Point { x:=b.x; y:=b.y+b.height/2; };
						_end := object DC::Point { x:=b.x+b.width; y:=b.y+b.height/2; };
					};
				};
				if nextSI->notEmpty() then {
					var nextSIShape := shape.owningUmlDiagramElement.ownedUmlDiagramElement->any(s|
						s.umlModelElement.oclAsType(UML::Element) = nextSI).oclAsType(DI::Shape);
					if nextSIShape->notEmpty() then {
						var nb := nextSIShape.bounds;
						group.member += object DG::Line {
							start := object DC::Point { x:=b.x+b.width; y:=b.y+b.height/2; };
							_end := object DC::Point { x:=b.x+b.width; y:=nb.y+nb.height/2; };
						};
					} endif;
				} endif;
				result := group;
			} endif
		} endif endif;
	}
}

mapping UML::StateMachine::shapeToSpecialNotation(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := shapeToFrame(shape);
	}
}

mapping UML::StructuredActivityNode::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := object DG::Rectangle {
			bounds := shape.bounds.clone().oclAsType(DC::Bounds);
			cornerRadius := 10;
			_class := "dashed";
		}
	}
}

mapping UML::TimeConstraint::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := object DG::Group {}
	}
}

mapping UML::UseCase::shapeToSpecialNotation(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
			var b = shape.bounds;
			result := object DG::Ellipse {
				center := object DC::Point {x:=b.x+b.width/2; y:=b.y+b.height/2};
				radii := object DC::Dimension {width:=b.width/2; height:=b.height/2};
			}
	}
}

