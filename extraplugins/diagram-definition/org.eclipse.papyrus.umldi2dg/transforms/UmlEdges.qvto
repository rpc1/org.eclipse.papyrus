/**
 * Copyright (c) 2014 CEA LIST.
 *  
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 * Contributors:
 *  CEA LIST - Initial API and implementation
 */
import UmlUtilities;

modeltype DC uses "http://www.omg.org/spec/DD/20110901/DC";
modeltype DG uses "http://www.omg.org/spec/DD/20110901/DG";
modeltype DI uses "http://www.omg.org/spec/DD/20110901/DI";
modeltype UMLDI uses "http://www.omg.org/spec/UML/20131001/UMLDI";
modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";

library UmlEdges;

mapping UML::ActivityEdge::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow")
}

mapping UML::Association::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	var end1 := self.memberEnd->at(1);
	var end2 := self.memberEnd->at(2);
	
	if (end1.owner != self) then {
		if (end2.aggregation = UML::AggregationKind::composite) then {
			startMarker := edge.resolveDefinitions().getMarker("startSolidCircleSolidDiamondOpenArrow");
		} else if (end2.aggregation = UML::AggregationKind::shared) then {
			startMarker := edge.resolveDefinitions().getMarker("startSolidCircleHollowDiamondOpenArrow");
		} else {
			startMarker := edge.resolveDefinitions().getMarker("startSolidCircleOpenArrow");
		} endif endif;
	} else if (end1.isNavigable()) then {
		if (end2.aggregation = UML::AggregationKind::composite) then {
			startMarker := edge.resolveDefinitions().getMarker("startSolidDiamondOpenArrow");
		} else if (end2.aggregation = UML::AggregationKind::shared) then {
			startMarker := edge.resolveDefinitions().getMarker("startHollowDiamondOpenArrow");
		} else {
			startMarker := edge.resolveDefinitions().getMarker("startOpenArrow");
		} endif endif;
	} else {
		if (end2.aggregation = UML::AggregationKind::composite) then {
			startMarker := edge.resolveDefinitions().getMarker("startSolidDiamond");
		} else if (end2.aggregation = UML::AggregationKind::shared) then {
			startMarker := edge.resolveDefinitions().getMarker("startHollowDiamond");
		} endif endif;
	} endif endif;
	
	if (end2.owner != self) then {
		if (end1.aggregation = UML::AggregationKind::composite) then {
			endMarker := edge.resolveDefinitions().getMarker("endSolidCircleSolidDiamondOpenArrow");
		} else if (end1.aggregation = UML::AggregationKind::shared) then {
			endMarker := edge.resolveDefinitions().getMarker("endSolidCircleHollowDiamondOpenArrow");
		} else {
			endMarker := edge.resolveDefinitions().getMarker("endSolidCircleOpenArrow");
		} endif endif;
	} else if (end2.isNavigable()) then {
		if (end1.aggregation = UML::AggregationKind::composite) then {
			endMarker := edge.resolveDefinitions().getMarker("endSolidDiamondOpenArrow");
		} else if (end1.aggregation = UML::AggregationKind::shared) then {
			endMarker := edge.resolveDefinitions().getMarker("endHollowDiamondOpenArrow");
		} else {
			endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");
		} endif endif;
	} else {
		if (end1.aggregation = UML::AggregationKind::composite) then {
			endMarker := edge.resolveDefinitions().getMarker("endSolidDiamond");
		} else if (end1.aggregation = UML::AggregationKind::shared) then {
			endMarker := edge.resolveDefinitions().getMarker("endHollowDiamond");
		} endif endif;
	} endif endif;
}

mapping UML::AssociationClass::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path
	inherits UML::Association::edgeToPath;

mapping UML::Dependency::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	if not edge.targetDiagramElement.oclIsKindOf(UMLDI::DependencyShape) then
		endMarker := edge.resolveDefinitions().getMarker("endOpenArrow")
	endif;
}

mapping UML::Element::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
}

mapping UML::ElementImport::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");		
}

mapping UML::ExceptionHandler::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow")
}

mapping UML::Extend::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");		
}

mapping UML::Extension::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	endMarker := edge.resolveDefinitions().getMarker("endSolidClosedArrow");		
}

mapping UML::Generalization::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	endMarker := edge.resolveDefinitions().getMarker("endHollowClosedArrow");		
}

mapping UML::GeneralizationSet::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
}

mapping UML::GeneralOrdering::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	var f := edge.waypoint->first();
	var l := edge.waypoint->last();
	
	command += object DG::MoveTo { point := f.clone().oclAsType(DC::Point) };
	command +=  object DG::LineTo { point := object DC::Point { x:=(f.x+l.x)/2; y:=(f.y+l.y)/2 } };
	command +=  object DG::LineTo { point := l.clone().oclAsType(DC::Point) };

	midMarker := edge.resolveDefinitions().getMarker("midSolidClosedArrow");
	_class := "dashed";
}
		
mapping UML::Include::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");		
}

mapping UML::InformationFlow::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");		
}

mapping UML::InterfaceRealization::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path 
	inherits UML::Realization::edgeToPath
{
	if not edge.targetUmlDiagramElement.oclAsType(ClassifierShape).useClassifierNotation then {
		_class := "";
		endMarker := null;		
	} endif;
}

mapping UML::Message::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	if self.messageSort = UML::MessageSort::synchCall then { 
		if self.messageKind = UML::MessageKind::lost then
			endMarker := edge.resolveDefinitions().getMarker("endSolidCircleSolidClosedArrow")
		else 		
			endMarker := edge.resolveDefinitions().getMarker("endSolidClosedArrow")
		endif		
	} else if self.messageSort = UML::MessageSort::asynchCall or self.messageSort = UML::MessageSort::asynchSignal then {
		if self.messageKind = UML::MessageKind::lost then
			endMarker := edge.resolveDefinitions().getMarker("endSolidCircleOpenArrow")
		else 		
			endMarker := edge.resolveDefinitions().getMarker("endOpenArrow")
		endif		
	} else if self.messageSort = UML::MessageSort::reply then {
		if self.messageKind = UML::MessageKind::lost then
			endMarker := edge.resolveDefinitions().getMarker("endSolidCircleSolidClosedArrow")
		else 		
			endMarker := edge.resolveDefinitions().getMarker("endSolidClosedArrow")
		endif;
		_class := "dashed";
	} else if self.messageSort = UML::MessageSort::createMessage then {
		if self.messageKind = UML::MessageKind::lost then
			endMarker := edge.resolveDefinitions().getMarker("endSolidCircleOpenArrow")
		else 		
			endMarker := edge.resolveDefinitions().getMarker("endOpenArrow")
		endif;	
		_class := "dashed";
	} else if self.messageSort = UML::MessageSort::deleteMessage then {
		if self.messageKind = UML::MessageKind::lost then
			endMarker := edge.resolveDefinitions().getMarker("endSolidCircleSolidClosedArrow")
		else 		
			endMarker := edge.resolveDefinitions().getMarker("endSolidClosedArrow")
		endif;
	} else if self.messageSort = UML::MessageSort::deleteMessage then {
		if self.messageKind = UML::MessageKind::lost then
			endMarker := edge.resolveDefinitions().getMarker("endSolidCircleSolidClosedArrow")
		else 		
			endMarker := edge.resolveDefinitions().getMarker("endSolidClosedArrow")
		endif;
	} endif endif endif endif endif endif;
	if self.messageKind = UML::MessageKind::found then
		startMarker := edge.resolveDefinitions().getMarker("startSolidCircle")
	endif;
}

mapping UML::PackageImport::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");		
}

mapping UML::PackageMerge::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");		
}

mapping UML::ProfileApplication::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");		
}

mapping UML::Property::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	var association := self.association;
	
	if (self.aggregation = UML::AggregationKind::composite) then {
		startMarker := edge.resolveDefinitions().getMarker("startSolidDiamond");
	} else if (self.aggregation = UML::AggregationKind::shared) then {
		startMarker := edge.resolveDefinitions().getMarker("startHollowDiamond");
	} endif endif;

	if (self.owner != association) then {
		endMarker := edge.resolveDefinitions().getMarker("endSolidCircleOpenArrow");
	} else if (self.isNavigable()) then {
		endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");
	} endif endif;
}

mapping UML::Realization::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endHollowClosedArrow");		
}

mapping UML::Substitution::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");		
}

mapping UML::TemplateBinding::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "dashed";
	endMarker := edge.resolveDefinitions().getMarker("endHollowClosedArrow");		
}

mapping UML::Transition::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	endMarker := edge.resolveDefinitions().getMarker("endOpenArrow");
	if self.redefinedTransition->notEmpty() then
		_class := "dashed"
	endif;
}

mapping UML::Usage::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path 
	inherits UML::Dependency::edgeToPath
{
	if edge.targetUmlDiagramElement.oclIsKindOf(UMLDI::InterfaceShape) and 
		not edge.targetDiagramElement.oclAsType(UMLDI::InterfaceShape).useClassifierNotation then {
		_class := "";
		endMarker := null;		
	} endif;
}

