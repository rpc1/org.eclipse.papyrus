/**
 * Copyright (c) 2014 CEA LIST.
 *  
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 * Contributors:
 *  CEA LIST - Initial API and implementation
 */
import UmlUtilities;

modeltype DC uses "http://www.omg.org/spec/DD/20110901/DC";
modeltype DG uses "http://www.omg.org/spec/DD/20110901/DG";
modeltype DI uses "http://www.omg.org/spec/DD/20110901/DI";
modeltype UMLDI uses "http://www.omg.org/spec/UML/20131001/UMLDI";
modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";

library UmlLabels;

query UML::Abstraction::keywords(label : UMLDI::UmlLabel) : String {
	return 'abstraction';
}

query UML::ActionExecutionSpecification::signature(label : UMLDI::UmlLabel) : String {
	return if self.action->notEmpty() then
		self.action.name(label)
	endif;
}

mapping UML::Activity::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	var classifierShape := label.owningUmlDiagramElement.oclAsType(UMLDI::ClassifierShape);
	if  label.oclIsKindOf(UMLDI::MainLabel) and not classifierShape.useClassifierNotation then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::Activity::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'activity';
}

query UML::Activity::nonClassifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return if self.isSingleExecution then
		'singleExecution'
	endif;
}

query UML::ActivityEdge::guardLabelToString(label : UMLDI::GuardLabel) : String {
	return if self.guard->notEmpty() then 
		replaceIfNotEmpty('', self.guard.signature(label), '[<n>]') 
	endif;
}

query UML::ActivityEdge::weightLabelToString(label : UMLDI::WeightLabel) : String {
	return if self.weight->notEmpty() then
		replaceIfNotEmpty('', self.weight.signature(label), 'weight=<n>')
	endif;
}

mapping UML::ActivityPartition::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	var activityPartitionShape := label.owningDiagramElement.oclAsType(UMLDI::ActivityPartitionShape);
	if label.oclIsKindOf(UMLDI::MainLabel) and not activityPartitionShape.isVertical then {
		var b = label.bounds;
		transform += object DG::Rotate {
			angle := -90;
			center := object DC::Point { x:=b.x+b.width/2; y:=b.y+b.height/2};
		}
	} endif;
}

query UML::AnyReceiveEvent::signature(label : UMLDI::UmlLabel) : String {
	return 'all';
}

query UML::Artifact::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'artifact';
}

query UML::Behavior::signature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.name(label), self.kind(label), '<n>/<o>');
}

query UML::Behavior::kind(label : UMLDI::UmlLabel) : String {
	return if self.owner.oclIsKindOf(UML::State) then
		if self.owner.oclAsType(UML::State).entry = self then
			'entry'
		else if self.owner.oclAsType(UML::State).exit = self then
			'exit'
		else
			'do'
		endif endif
	endif;
}

query UML::BehaviorExecutionSpecification::signature(label : UMLDI::UmlLabel) : String {
	return if self.behavior->notEmpty() then
		self.behavior.name(label)
	endif;
}

query UML::BehavioralFeature::listItemSignature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.signature(label), self.visibility(label), '<n><o>');
}

query UML::BehavioralFeature::signature(label : UMLDI::UmlLabel) : String {
	var s := self.name(label);
	s := replace(s, self.parameters(label), '<o>(<n>)');
	s := replaceIfNotEmpty(s, self.type(label), '<o>:<n>');
	s := replaceIfNotEmpty(s, self.multiplicity(label), '<o>[<n>]');
	return s;
}

query UML::BehavioralFeature::multiplicity(label : UMLDI::UmlLabel) : String {
	var returnValue = self.ownedParameter->any(direction = UML::ParameterDirectionKind::_return);
	return if returnValue->notEmpty() then returnValue.multiplicity(label) endif;
}

query UML::BehavioralFeature::parameters(label : UMLDI::UmlLabel) : String {
	var parameters = self.ownedParameter->reject(direction = UML::ParameterDirectionKind::_return);
	return parameters.signature(label)->separate();
}

query UML::BehavioralFeature::type(label : UMLDI::UmlLabel) : String {
	var returnValue = self.ownedParameter->any(direction = UML::ParameterDirectionKind::_return);
	return if returnValue->notEmpty() then returnValue.type(label) endif;
}

query UML::CallEvent::signature(label : UMLDI::UmlLabel) : String {
	return if self.operation->notEmpty() then self.operation.name(label) endif;
}

query UML::CentralBufferNode::keywords(label : UMLDI::UmlLabel) : String {
	return 'centralBuffer';
}

query UML::ChangeEvent::signature(label : UMLDI::UmlLabel) : String {
	return if self.changeExpression->notEmpty() then 
		replaceIfNotEmpty('', self.changeExpression.signature(label), 'when <n>')
	endif;
}

mapping UML::Class::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if self.isAbstract then
		result.createStyleIfNeeded().fontItalic := true
	endif;
}

query UML::Classifier::keywords(label : UMLDI::UmlLabel) : String {
	return if label.owningUmlDiagramElement.oclIsKindOf(ClassifierShape) and 
		label.owningUmlDiagramElement.oclAsType(ClassifierShape).useClassifierNotation then 
		self.classifierShapeKeywords(label)
	else 
		self.nonClassifierShapeKeywords(label)
	endif;
}

query UML::Classifier::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return '';
}

query UML::Classifier::nonClassifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return '';
}

query UML::Collaboration::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'collaboration';
}

query UML::CollaborationUse::signature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.name(label), self.type(label), '<o>:<n>');
}

query UML::CollaborationUse::type(label : UMLDI::UmlLabel) : String {
	return if self.type->notEmpty() then self.type.name(label) endif;
}

query UML::CombinedFragment::signature(label : UMLDI::UmlLabel) : String {
	var s:= self.operator(label);
	if self.interactionOperator = UML::InteractionOperatorKind::loop then
		if self.operand->notEmpty() then
			if self.operand->at(1).guard->notEmpty() then
				s := replace(s, self.operand->at(1).guard.multiplicity(label), '<o>(<n>)')
			endif
		endif
	endif;
	return s;
}

query UML::CombinedFragment::operator(label : UMLDI::UmlLabel) : String {
	return self.interactionOperator.toString();
}

mapping UML::CombinedFragment::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if  label.oclIsKindOf(UMLDI::MainLabel) then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::Comment::signature(label : UMLDI::UmlLabel) : String {
	return self.body(label);
}

query UML::Comment::body(label : UMLDI::UmlLabel) : String {
	return if not self.body.oclIsUndefined() then self.body endif;
}

mapping UML::Comment::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if  label.oclIsKindOf(UMLDI::MainLabel) then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::Component::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'component';
}

query UML::ConnectionPointReference::signature(label : UMLDI::UmlLabel) : String {
	return if self.entry->notEmpty() then
		self.entry.name(label)->separate()
	else if self.exit->notEmpty() then
		self.exit.name(label)->separate()
	endif endif;	
}

query UML::Connector::signature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.name(label), self.type(label), '<o>:<n>');
}

query UML::Connector::type(label : UMLDI::UmlLabel) : String {
	return if self.type->notEmpty() then self.type.name(label) endif;
}

query UML::ConsiderIgnoreFragment::signature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.operator(label), self.message.name(label)->separate(), '<o>{<n>}');
}

mapping UML::Constraint::constraintLabelToGraphicalElement(label : ConstraintLabel) : DG::GraphicalElement {
	init {
		if label.owningUmlDiagramElement.oclIsKindOf(ActionShape) then
			result := self.map labelToNoteShape(label)
		else
			result := self.map labelToText(label)
		endif;
	}
}

query UML::Constraint::constraintLabelToString(label : UMLDI::ConstraintLabel) : String {
	var s := self.signature(label);
	s := replaceIfNotEmpty(s, self.taggedValues(label), '{<n>}\n<o>');
	s := replaceIfNotEmpty(s, self.stereotypes(label), '«<n>»\n<o>');
	s := replaceIfNotEmpty(s, self.keywords(label), '«<n>»\n<o>');
	return s;
}

query UML::Constraint::signature(label : UMLDI::UmlLabel) : String {
	var s := replaceIfNotEmpty('', self.name(label), '<n>: ');
	s := replace(s, self.specification(label), '{<o><n>}');
	return s;
}

query UML::Constraint::specification(label : UMLDI::UmlLabel) : String {
	return if self.specification->notEmpty() then self.specification.signature(label) endif;
}

query UML::Constraint::keywords(label : UMLDI::UmlLabel) : String {
	return if self.owner.oclIsKindOf(UML::Action) then
		if self.owner.oclAsType(Action).localPrecondition->includes(self) then
			'localPrecondition'
		else if self.owner.oclAsType(Action).localPostcondition->includes(self) then
			'localPostcondition'
		endif endif
	endif;
}

query UML::Constraint::listItemKeywords(label : UMLDI::UmlLabel) : String {
	var compartment := label.owningUmlDiagramElement;
	return if compartment.oclIsKindOf(UMLDI::PreConditionCompartment) then
		'precondition'
	else if compartment.oclIsKindOf(UMLDI::PostConditionCompartment) then
		'postcondition'
	endif endif;
}

mapping UML::Constraint::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	anchor := DG::TextAnchor::start;
}

query UML::DataType::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'datatype';
}

query UML::DataStoreNode::keywords(label : UMLDI::UmlLabel) : String {
	return 'datastore';
}

query UML::Deployment::keywords(label : UMLDI::UmlLabel) : String {
	return 'deploy';
}

query UML::DeploymentSpecification::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'deployment spec';
}

query UML::Device::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'device';
}

query UML::Duration::value(label : UMLDI::UmlLabel) : String {
	return if self.expr->notEmpty() then 
		self.expr.signature(label) 
	else
		self.observation.signature(label)->separate() 
	endif;
}

mapping UML::Element::labelToGraphicalElement(label : UMLDI::UmlLabel) : DG::GraphicalElement {
	init {
		result := switch {
			case (label.oclIsKindOf(UMLDI::StereotypeLabel)) 
				self.map stereotypeLabelToGraphicalElement(label.oclAsType(UMLDI::StereotypeLabel));
			case (label.oclIsKindOf(UMLDI::ConstraintLabel)) 
				self.map constraintLabelToGraphicalElement(label.oclAsType(UMLDI::ConstraintLabel));
			case (label.oclIsKindOf(UMLDI::SelectionLabel)) 
				self.map selectionLabelToGraphicalElement(label.oclAsType(UMLDI::SelectionLabel));
			case (label.oclIsKindOf(UMLDI::TransformationLabel)) 
				self.map transformationLabelToGraphicalElement(label.oclAsType(UMLDI::TransformationLabel));
			case (label.oclIsKindOf(UMLDI::MessageLabel)) 
				self.map messageLabelToGraphicalElement(label.oclAsType(UMLDI::MessageLabel));
			case (label.oclIsKindOf(UMLDI::IconLabel)) 
				self.map iconLabelToGraphicalElement(label.oclAsType(UMLDI::IconLabel));
			else
				self.map labelToText(label);
		};
	}
}

mapping UML::Element::iconLabelToGraphicalElement(label : IconLabel) : DG::GraphicalElement {
	init {
	// no default implementation
	}
}

mapping UML::Element::messageLabelToGraphicalElement(label : MessageLabel) : DG::GraphicalElement {
	init {
	// no default implementation
	}
} 

mapping UML::Element::selectionLabelToGraphicalElement(label : SelectionLabel) : DG::GraphicalElement {
	init {
		result := self.map labelToNoteShape(label);
	}
} 

mapping UML::Element::transformationLabelToGraphicalElement(label : TransformationLabel) : DG::GraphicalElement {
	init {
		result := self.map labelToNoteShape(label);
	}
} 

mapping UML::Element::stereotypeLabelToGraphicalElement(label : StereotypeLabel) : DG::GraphicalElement {
	init {
		result := self.map labelToNoteShape(label);
	}
} 

mapping UML::Element::constraintLabelToGraphicalElement(label : ConstraintLabel) : DG::GraphicalElement {
	init {
		result := self.map labelToText(label);
	}
} 

mapping UML::Element::labelToText(label : UMLDI::UmlLabel) : DG::Text {
	data := self.labelToString(label);
	bounds := label.bounds.clone().oclAsType(DC::Bounds);
	if (label.oclIsKindOf(UMLDI::ListItemLabel)) then
		anchor := DG::TextAnchor::start
	else
		anchor := DG::TextAnchor::middle
	endif;
}

mapping UML::Element::labelToNoteShape(label : UMLDI::UmlLabel) : DG::Group {
	init {
		result := object DG::Group {
			member += createNoteShape(label);
			member += createNoteAttachment(label);
			var text := self.map labelToText(label);
			member += text;
			// some insets form the border
			var inset := 2;
			text.bounds.x := text.bounds.x+inset;
			text.bounds.y := text.bounds.y+inset;
			text.bounds.width := text.bounds.width-2*inset;
			text.bounds.height := text.bounds.height-2*inset;
		};
	}
}

query UML::Element::labelToString(label : UMLDI::UmlLabel) : String {
	return switch {
		case (label.oclIsKindOf(UMLDI::MainLabel)) 
			self.mainLabelToString(label.oclAsType(UMLDI::MainLabel));
		case (label.oclIsKindOf(UMLDI::StereotypeLabel)) 
			self.stereotypeLabelToString(label.oclAsType(UMLDI::StereotypeLabel));
		case (label.oclIsKindOf(UMLDI::ListItemLabel)) 
			self.listItemLabelToString(label.oclAsType(UMLDI::ListItemLabel));
		case (label.oclIsKindOf(UMLDI::RoleLabel)) 
			self.roleLabelToString(label.oclAsType(UMLDI::RoleLabel));
		case (label.oclIsKindOf(UMLDI::MultiplicityLabel)) 
			self.multiplicityLabelToString(label.oclAsType(UMLDI::MultiplicityLabel));
		case (label.oclIsKindOf(UMLDI::ConstraintLabel)) 
			self.constraintLabelToString(label.oclAsType(UMLDI::ConstraintLabel));
		case (label.oclIsKindOf(UMLDI::PowerLabel)) 
			self.powerLabelToString(label.oclAsType(UMLDI::PowerLabel));
		case (label.oclIsKindOf(UMLDI::ConveyedLabel)) 
			self.conveyedLabelToString(label.oclAsType(UMLDI::ConveyedLabel));
		case (label.oclIsKindOf(UMLDI::GuardLabel)) 
			self.guardLabelToString(label.oclAsType(UMLDI::GuardLabel));
		case (label.oclIsKindOf(UMLDI::WeightLabel)) 
			self.weightLabelToString(label.oclAsType(UMLDI::WeightLabel));
		case (label.oclIsKindOf(UMLDI::SelectionLabel)) 
			self.selectionLabelToString(label.oclAsType(UMLDI::SelectionLabel));
		case (label.oclIsKindOf(UMLDI::TransformationLabel)) 
			self.transformationLabelToString(label.oclAsType(UMLDI::TransformationLabel));
		case (label.oclIsKindOf(UMLDI::TypeLabel)) 
			self.typeLabelToString(label.oclAsType(UMLDI::TypeLabel));
		case (label.oclIsKindOf(UMLDI::MessageLabel)) 
			self.messageLabelToString(label.oclAsType(UMLDI::MessageLabel));
		else
			'<LABEL>';
	};
}

query UML::Element::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := self.signature(label);
	s := replaceIfNotEmpty(s, self.taggedValues(label), '{<n>}\n<o>');
	s := replaceIfNotEmpty(s, self.stereotypes(label), '«<n>»\n<o>');
	s := replaceIfNotEmpty(s, self.keywords(label), '«<n>»\n<o>');
	return s;
}

query UML::Element::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	var s := self.listItemSignature(label);
	s := replaceIfNotEmpty(s, self.taggedValues(label), '{<n>}<o>');
	s := replaceIfNotEmpty(s, self.stereotypes(label), '«<n>»<o>');
	s := replaceIfNotEmpty(s, self.listItemKeywords(label), '«<n>»<o>');
	return s;
}

query UML::Element::stereotypeLabelToString(label : UMLDI::StereotypeLabel) : String {
	var s : String;
	self.getAppliedStereotypes()->forEach(stereotype) {
		s := replace(s, stereotype.name(label), '<o>\n«<n>»');
		s := replace(s, self.taggedValues(stereotype, label)->separate('\n'), '<o>\n<n>');
	};
	return s;
}

query UML::Element::conveyedLabelToString(label : UMLDI::ConveyedLabel) : String {
	return '<CONVEYED>';
}

query UML::Element::constraintLabelToString(label : UMLDI::ConstraintLabel) : String {
	return '<CONSTRAINT>';
}

query UML::Element::multiplicityLabelToString(label : UMLDI::MultiplicityLabel) : String {
	return '<MULTIPLICITY>';
}

query UML::Element::roleLabelToString(label : UMLDI::RoleLabel) : String {
	return '<ROLE>';
}

query UML::Element::powerLabelToString(label : UMLDI::PowerLabel) : String {
	return '<POWER>';
}

query UML::Element::messageLabelToString(label : UMLDI::MessageLabel) : String {
	return '<MESSAGE>';
}

query UML::Element::guardLabelToString(label : UMLDI::GuardLabel) : String {
	return '<GUARD>';
}

query UML::Element::weightLabelToString(label : UMLDI::WeightLabel) : String {
	return '<WEIGHT>';
}

query UML::Element::selectionLabelToString(label : UMLDI::SelectionLabel) : String {
	return '<SELECTION>';
}

query UML::Element::transformationLabelToString(label : UMLDI::TransformationLabel) : String {
	return '<TRANSFORMATION>';
}

query UML::Element::typeLabelToString(label : UMLDI::TypeLabel) : String {
	return '<TYPE>';
}

query UML::Element::signature(label : UMLDI::UmlLabel) : String {
	return '';
}

query UML::Element::listItemSignature(label : UMLDI::UmlLabel) : String {
	return self.signature(label);
}

query UML::Element::stereotypes(label : UMLDI::UmlLabel) : String {
	return self.getAppliedStereotypes().name(label)->separate();
}

query UML::Element::taggedValues(label : UMLDI::UmlLabel) : String {
	var stereotypedDiagramElement := if label.oclIsKindOf(UMLDI::StereotypedDiagramElement) then
		label.oclAsType(UMLDI::StereotypedDiagramElement)
	else
		label.owningUmlDiagramElement.oclAsType(UMLDI::StereotypedDiagramElement)
	endif;	
	return if stereotypedDiagramElement.showStereotypeAttributes then
		self.getAppliedStereotypes()->collect(stereotype|self.taggedValues(stereotype, label))->separate()
	endif;
}

query UML::Element::taggedValues(stereotype : Stereotype, label : UMLDI::UmlLabel) : Collection(String) {
	return stereotype.allAttributes()->select(type.oclIsKindOf(UML::DataType))->
		collect(attribute|self.taggedValue(stereotype, attribute, label));
}

query UML::Element::keywords(label : UMLDI::UmlLabel) : String {
	return '';
}

query UML::Element::listItemKeywords(label : UMLDI::UmlLabel) : String {
	return self.keywords(label);
}

query UML::Element::taggedValue(stereotype : Stereotype, attribute : Property, label : UMLDI::UmlLabel) : String {
	return replace(attribute.name(label), self.getValue(stereotype, attribute.name).toString(), '<o>=<n>');
}

query UML::ElementImport::signature(label : UMLDI::UmlLabel) : String {
	var s := self.alias(label);
	return s;
}

query UML::ElementImport::alias(label : UMLDI::UmlLabel) : String {
	return if not self.alias.oclIsUndefined() then self.alias endif;
}

query UML::ElementImport::keywords(label : UMLDI::UmlLabel) : String {
	var v = if self.visibility = UML::VisibilityKind::public then 'import' else 'access' endif;
	var e = if self.importedElement.oclIsKindOf(UML::Package) then 'element' else '' endif;
	return replaceIfNotEmpty(v, e, '<n> <o>');
}

query UML::Enumeration::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'enumeration';
}

mapping UML::EnumerationLiteral::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	/* inherit from Element instead of InstanceSpecification */
}

query UML::EnumerationLiteral::signature(label : UMLDI::UmlLabel) : String {
	return self.name(label);
}

query UML::ExceptionHandler::typeLabelToString(label : UMLDI::TypeLabel) : String {
	return self.exceptionType.name(label)->separate('\n');
}

mapping UML::ExceptionHandler::iconLabelToGraphicalElement(label : IconLabel) : DG::GraphicalElement {
	init {
		var b := label.bounds;
		result := object DG::Path {
			command += object DG::MoveTo { point := object DC::Point { x := b.x; y := b.y; } };
			command += object DG::LineTo { point := object DC::Point { x := b.x+b.width; y := b.y; } };
			command += object DG::LineTo { point := object DC::Point { x := b.x; y := b.y+b.height; } };
			command += object DG::LineTo { point := object DC::Point { x := b.x+b.width; y := b.y+b.height; } };
			endMarker := label.resolveDefinitions().getMarker('endSolidClosedArrowSmall');
		};
	}		
}

query UML::ExecutionEnvironment::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'executionEnvironment';
}

query UML::Expression::value(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.symbol(label), self.operand.signature(label)->separate(), '<o>(<n>)');
}

query UML::Expression::symbol(label : UMLDI::UmlLabel) : String {
	return if not self.symbol.oclIsUndefined() then self.symbol endif;
}

query UML::Expression::inputValue(label : UMLDI::UmlLabel) : String {
	return if self.symbol(label).size()=0 and self.operand->isEmpty() then
		'-'
	else
		self.signature(label)
	endif;
}

query UML::Expression::outputValue(label : UMLDI::UmlLabel) : String {
	return if self.operand->notEmpty() then
		self.operand->at(1).signature(label)
	else
		self.signature(label)
	endif;
}

query UML::Expression::assignmentTarget(label : UMLDI::UmlLabel) : String {
	return self.symbol(label);
}

query UML::Extend::keywords(label : UMLDI::UmlLabel) : String {
	return 'extend';
}

query UML::FunctionBehavior::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'functionalBehavior';
}

query UML::GeneralizationSet::constraintLabelToString(label : UMLDI::ConstraintLabel) : String {
	return replace(self.covering(label), self.disjoint(label), '{<o>,<n>}');
}

query UML::GeneralizationSet::powerLabelToString(label : UMLDI::PowerLabel) : String {
	return replaceIfNotEmpty('', self.powerType(label), ':<n>');
}

query UML::GeneralizationSet::powerType(label : UMLDI::UmlLabel) : String {
	return if self.powertype->notEmpty() then self.powertype.name(label) endif;
}

query UML::GeneralizationSet::covering(label : UMLDI::UmlLabel) : String {
	return if self.isCovering then 'complete' else 'incomplete' endif;
}

query UML::GeneralizationSet::disjoint(label : UMLDI::UmlLabel) : String {
	return if self.isDisjoint then 'disjoint' else 'overlapping' endif;
}

query UML::Include::keywords(label : UMLDI::UmlLabel) : String {
	return 'include';
}

query UML::InformationFlow::conveyedLabelToString(label : UMLDI::ConveyedLabel) : String {
	return self.conveyed(label);
}

query UML::InformationFlow::conveyed(label : UMLDI::UmlLabel) : String {
	return self.conveyed.name(label)->separate();
}

query UML::InformationFlow::keywords(label : UMLDI::UmlLabel) : String {
	return 'flow';
}

query UML::InformationItem::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'information';
}

mapping UML::InstanceSpecification::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if label.oclIsKindOf(UMLDI::MainLabel) then
		_class := 'underlined'
	endif;
}

mapping UML::Interaction::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	var classifierShape := label.owningUmlDiagramElement.oclAsType(UMLDI::ClassifierShape);
	if  label.oclIsKindOf(UMLDI::MainLabel) and not classifierShape.useClassifierNotation then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::InstanceSpecification::signature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.name(label), self.type(label), '<o>:<n>');
}

query UML::InstanceSpecification::type(label : UMLDI::UmlLabel) : String {
	return if self.classifier->notEmpty() then self.classifier.name(label)->separate() endif;
}

query UML::InstanceValue::value(label : UMLDI::UmlLabel) : String {
	return if self.instance->notEmpty() then self.instance.signature(label) endif;
}

query UML::Interaction::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'interaction';
}

query UML::Interaction::signature(label : UMLDI::UmlLabel) : String {
	return if label.diagram.oclIsKindOf(UMLDI::SequenceDiagram) then
		replace('', self.name(label), 'sd:<n>')
	else
		self.name(label)
	endif;
}

query UML::InteractionConstraint::multiplicity(label : UMLDI::UmlLabel) : String {
	var min := self.min(label);
	var max := self.max(label);
	return if min = max then
		min
	else
		replace(self.min(label), self.max(label), '<o>,<n>')
	endif;
}

query UML::InteractionConstraint::min(label : UMLDI::UmlLabel) : String {
	return if not self.minint.oclIsUndefined() then self.minint.signature(label) endif;
}

query UML::InteractionConstraint::max(label : UMLDI::UmlLabel) : String {
	return if not self.maxint.oclIsUndefined() then self.maxint.signature(label) endif;
}

query UML::InteractionOperand::name(label : UMLDI::UmlLabel) : String {
	return if self.guard->notEmpty() then 
		replace('', self.guard.specification(label), '[<n>]')
	endif;
}

query UML::InteractionUse::mainLabelToString(label : UMLDI::MainLabel) : String {
	return 'ref';
}

query UML::InteractionUse::typeLabelToString(label : UMLDI::TypeLabel) : String {
	var s := self.signature(label);
	s := replaceIfNotEmpty(s, self.taggedValues(label), '{<n>}\n<o>');
	s := replaceIfNotEmpty(s, self.stereotypes(label), '«<n>»\n<o>');
	s := replaceIfNotEmpty(s, self.keywords(label), '«<n>»\n<o>');
	return s;
}

query UML::InteractionUse::signature(label : UMLDI::UmlLabel) : String {
	var s := self.refersTo(label);
	s := replaceIfNotEmpty(s, self.collaborationUse(label), '<n>.<o>');
	s := replaceIfNotEmpty(s, self.arguments(label), '<o>(<n>)');
	s := replaceIfNotEmpty(s, self.returnValue(label), '<o>:<n>');
	s := replaceIfNotEmpty(s, self.returnValueRecipient(label), '<n>=<o>');
	return s;
}

query UML::InteractionUse::refersTo(label : UMLDI::UmlLabel) : String {
	return if self.refersTo->notEmpty() then self.refersTo.name(label) endif;
}

query UML::InteractionUse::collaborationUse(label : UMLDI::UmlLabel) : String {
	if self.enclosingInteraction.owner.oclIsKindOf(UML::Classifier) then {
		var c := self.enclosingInteraction.owner.oclAsType(UML::Classifier);
		var r := self.covered.represents;
		var cu := c.collaborationUse->any(roleBinding.supplier->includesAll(r));
		return if not cu.oclIsUndefined() then cu.name(label) endif;
	} endif;
	return '';
}

query UML::InteractionUse::arguments(label : UMLDI::UmlLabel) : String {
	if self.refersTo->notEmpty() then {
		var parameters := self.refersTo.ownedParameter->reject(direction = UML::ParameterDirectionKind::_return);
		return List{1..self.argument->size()}->collect(i|self.argument(self.argument->at(i), parameters->at(i), label))->separate();
	} endif;
	return '';
}

query UML::InteractionUse::argument(argument : ValueSpecification, parameter : Parameter, label : UMLDI::UmlLabel) : String {
	return if parameter.direction = UML::ParameterDirectionKind::_in then
		argument.inputSignature(label)
	else
		'out '+argument.outputSignature(label)
	endif;
}

query UML::InteractionUse::returnValue(label : UMLDI::UmlLabel) : String {
	return if self.returnValue->notEmpty() then self.returnValue.outputValue(label) endif;
}

query UML::InteractionUse::returnValueRecipient(label : UMLDI::UmlLabel) : String {
	return if self.returnValueRecipient->notEmpty() then self.returnValueRecipient.name(label) endif;
}

query UML::Interface::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'interface';
}

query UML::Interval::value(label : UMLDI::UmlLabel) : String {
	return replace(self.min(label), self.max(label), '<o>..<n>');
}

query UML::Interval::min(label : UMLDI::UmlLabel) : String {
	return if not self.min.oclIsUndefined() then self.min.signature(label) endif;
}

query UML::Interval::max(label : UMLDI::UmlLabel) : String {
	return if not self.max.oclIsUndefined() then self.max.signature(label) endif;
}

mapping UML::Lifeline::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if label.diagram.oclIsKindOf(UMLDI::TimingDiagram) then {
		var b := label.bounds;
		transform += object DG::Rotate { angle:=-90; center:=object DC::Point {x:=b.x+b.width/2; y:=b.y+b.height/2} }
	} endif;
}

query UML::Lifeline::signature(label : UMLDI::UmlLabel) : String {
	var s := self.represents(label);
	if s <> 'self' then {
		s := replaceIfNotEmpty(s, self.selector(label), '<o>[<n>]');
		s := replaceIfNotEmpty(s, self.type(label), '<o>:<n>');
		s := replaceIfNotEmpty(s, self.decomposedAs(label), '<o> ref <n>');
	} endif;
	return s;
}

query UML::Lifeline::represents(label : UMLDI::UmlLabel) : String {
	return if self.represents->notEmpty() then
		self.represents.name(label)
	else
		self.name(label)
	endif
}

query UML::Lifeline::selector(label : UMLDI::UmlLabel) : String {
	return if self.selector->notEmpty() then self.selector.signature(label) endif;
}

query UML::Lifeline::type(label : UMLDI::UmlLabel) : String {
	return if self.represents->notEmpty() then self.represents.type(label) endif;
}

query UML::Lifeline::decomposedAs(label : UMLDI::UmlLabel) : String {
	return if self.decomposedAs->notEmpty() then
		if self.decomposedAs.refersTo->notEmpty() then
			self.decomposedAs.refersTo.name(label)
		endif
	endif;
}

query UML::LiteralBoolean::value(label : UMLDI::UmlLabel) : String {
	return self.value.repr();
}

query UML::LiteralInteger::value(label : UMLDI::UmlLabel) : String {
	return self.value.repr();
}

query UML::LiteralNull::value(label : UMLDI::UmlLabel) : String {
	return 'null';
}

query UML::LiteralReal::value(label : UMLDI::UmlLabel) : String {
	return self.value.repr();
}

query UML::LiteralString::value(label : UMLDI::UmlLabel) : String {
	return if not self.value.oclIsUndefined() then '"'+self.value+'"' endif;
}

query UML::LiteralUnlimitedNatural::value(label : UMLDI::UmlLabel) : String {
	return if self.value = -1 then '*' else self.value.repr() endif;
}

query UML::Manifestation::keywords(label : UMLDI::UmlLabel) : String {
	return 'manifest';
}

mapping UML::Message::messageLabelToGraphicalElement(label : MessageLabel) : DG::GraphicalElement {
	init {
		var src := self.sendEvent.oclAsType(UML::MessageOccurrenceSpecification).covered->any(true);
		var tgt := self.receiveEvent.oclAsType(UML::MessageOccurrenceSpecification).covered->any(true);

		var edge := label.owningUmlDiagramElement.oclAsType(UMLDI::UmlEdge);
		var x1 := edge.waypoint->at(1).x;
		var y1 := edge.waypoint->at(1).y;
		var x2 := edge.waypoint->at(2).x;
		var y2 := edge.waypoint->at(2).y;

		var b := label.bounds;
		var x3 := b.x+b.width/2;
		var y3 := b.y+b.height/2;
		var dx := x2 - x1;
		var dy := y2 - y1;
		var k  := (dy * (x3-x1) - dx * (y3-y1)) / (dy*dy + dx*dx);
		var x4 := x3 - k * dy;
		var y4 := y3 + k * dx;
		
		var a := atan2(dy, dx);
		if edge.sourceUmlDiagramElement.umlModelElement.oclAsType(UML::Lifeline) = tgt then
			a := a+180
		endif;
		
		result := object DG::Group {
			member += self.map labelToText(label);
			member += object DG::Path {
				command += object DG::MoveTo { point := object DC::Point { x := b.x+b.width/2-10; y := b.y+b.height+15; } };
				command += object DG::LineTo { point := object DC::Point { x := b.x+b.width/2+10; y := b.y+b.height+15; } };
				transform += object DG::Rotate { angle:=a; center:= object DC::Point { x:=b.x+b.width/2; y:=b.y+b.height+15 } };
				endMarker := label.resolveDefinitions().getMarker('endOpenArrowSmall');		
			}
		};
	}
} 

query UML::Message::messageLabelToString(label : UMLDI::MessageLabel) : String {
	var s := self.signature(label);
	s := replaceIfNotEmpty(s, self.taggedValues(label), '{<n>} <o>');
	s := replaceIfNotEmpty(s, self.stereotypes(label), '«<n>» <o>');
	s := replaceIfNotEmpty(s, self.keywords(label), '«<n>» <o>');
	return s;
}

query UML::Message::signature(label : UMLDI::UmlLabel) : String {
	var s := self.represents(label);
	if label.diagram.oclIsKindOf(UMLDI::CommunicationDiagram) then
		s := replaceIfNotEmpty(s, self.sequence(label), '<n>:<o>')
	endif;
	if self.messageSort = UML::MessageSort::reply then {
		s := replaceIfNotEmpty(s, self.outArguments(label), '<o>(<n>)');
		s := replaceIfNotEmpty(s, self.returnValues(label), '<o>:<n>');
		s := replaceIfNotEmpty(s, self.assignmentTargets(label), '<n>=<o>');
	} else {
		s := replaceIfNotEmpty(s, self.inArguments(label), '<o>(<n>)')
	} endif;
	return s;
}

query UML::Message::represents(label : UMLDI::UmlLabel) : String {
	return if self.signature->notEmpty() then
		self.signature.name(label)
	else
		self.name(label)
	endif;
}

/**
 * The algorithm only works for simple interactions typically created by communication diagrams
 * It assumes that all messages are sequential and not interleaving. It also assumes that no
 * combined fragment exists, i.e., all relevant fragments are directly owned by the interaction.
 * It further makes the following assumptions (which typically hold):
 * 1- A message's receive event is ordered directly following its send event
 * 2- An execution specification is ordered after a receive event of a message
 * 3- An execution specification's finish event is ordered some where after its start event
 */
query UML::Message::sequence(label : UMLDI::UmlLabel) : String {
	var allFragments := self.interaction.fragment;
	var sendEvent := allFragments[UML::MessageOccurrenceSpecification]->select(message = self)->first();
	var maxIndex = allFragments->indexOf(sendEvent);
	
	var visited : Set(UML::InteractionFragment);
	var finishEventStack : Sequence(UML::InteractionFragment);
	var indexStack : Sequence(Integer);
	var index : Integer;
	
	// iterate over fragments from the begining up to the send event of the message, 
	List{1..maxIndex}->forEach(i) {
		var fragment := allFragments->at(i);
		// does the current fragment represent a finish of an execution spec you visited before? 
		if finishEventStack->includes(fragment) then {
			// add the finished fragment to the visited ones
			visited := visited->including(fragment);
			// pop up from the top of the stack all finish fragments that have been visiteda and restore their index
			while(visited->includes(finishEventStack->last())) {
				index := indexStack->last();
				visited := visited->excluding(finishEventStack->last());
				finishEventStack := if finishEventStack->size()=1 then {} else finishEventStack->subSequence(1, finishEventStack->size()-1) endif;
				indexStack := if indexStack->size()=1 then {} else indexStack->subSequence(1, indexStack->size()-1) endif;
			}
		} endif;
		if fragment.oclIsKindOf(UML::MessageOccurrenceSpecification) then {
			// increase the index whenever you visit a send event 
			var mo := fragment.oclAsType(UML::MessageOccurrenceSpecification);
			if mo.message.sendEvent = mo then
				index := index+1
			endif
		} else if fragment.oclIsKindOf(UML::ExecutionSpecification) then {
			// push the finish event of any execution specification you visit on the stack 
			var es := fragment.oclAsType(UML::ExecutionSpecification);
			finishEventStack := finishEventStack->append(es.finish);
			indexStack := indexStack->append(index);
			index := 0;
		} endif endif;
	};
	
	// return the current index prefixed with the index stack (representing the nesting elvel)
	return indexStack->append(index).toString()->separate('.');
}

query UML::Message::inArguments(label : UMLDI::UmlLabel) : String {
	return self.argument->collect(inputSignature(label))->separate();
}

query UML::Message::outArguments(label : UMLDI::UmlLabel) : String {
	if self.signature->notEmpty() and self.signature.oclIsKindOf(UML::Operation) then {
		var rp := self.signature.oclAsType(UML::Operation).returnResult();
		var ra = self.argument->select(a|rp.name->excludes(a.name));
		return ra->collect(outputSignature(label))->separate()
	} endif;
	return ''
}

query UML::Message::returnValues(label : UMLDI::UmlLabel) : String {
	if self.signature->isEmpty() then
		if self.argument->notEmpty() then
			return self.argument->at(1).outputValue(label)
		endif
	else if self.signature.oclIsKindOf(UML::Operation) then {
		var rp := self.signature.oclAsType(UML::Operation).returnResult();
		var ra = self.argument->select(a|rp.name->includes(a.name));
		return ra->collect(outputValue(label))->separate()
	} endif endif;
	return '';
}

query UML::Message::assignmentTargets(label : UMLDI::UmlLabel) : String {
	if self.signature->isEmpty() then {
		if self.argument->notEmpty() then
			return self.argument->at(1).assignmentTarget(label)
		endif
	} else if self.signature.oclIsKindOf(UML::Operation) then {
		var rp := self.signature.oclAsType(UML::Operation).returnResult();
		var ra = self.argument->select(a|rp.name->includes(a.name));
		return ra.assignmentTarget(label)->separate()
	} endif endif;
	return '';
}

query UML::MultiplicityElement::multiplicityLabelToString(label : UMLDI::MultiplicityLabel) : String {
	var s := self.multiplicity(label);
	return s;
}

query UML::MultiplicityElement::multiplicity(label : UMLDI::UmlLabel) : String {
	var lower = self.lower(label);
	var upper = self.upper(label);
	return switch {
		case (lower = '1' and upper = '1' and not label.oclIsKindOf(UMLDI::MultiplicityLabel)) '';
		case (lower = '0' and upper = '*') '*';
		case (lower = upper) lower;
		else replace(lower, upper, '<o>..<n>');
	};
}

query UML::MultiplicityElement::lower(label : UMLDI::UmlLabel) : String {
	return if not self.lowerValue.oclIsUndefined() then 
		self.lowerValue.signature(label) 
	else 
		'1' 
	endif;
}

query UML::MultiplicityElement::upper(label : UMLDI::UmlLabel) : String {
	return if not self.upperValue.oclIsUndefined() then 
		self.upperValue.signature(label) 
	else 
		'1' 
	endif;
}

query UML::NamedElement::signature(label : UMLDI::UmlLabel) : String {
	return self.name(label);
}

query UML::NamedElement::name(label : UMLDI::UmlLabel) : String {
	return if self.name.oclIsUndefined() then '' else self.name endif;
}

query UML::NamedElement::visibility(label : UMLDI::UmlLabel) : String {
	return switch {
		case (self.visibility = UML::VisibilityKind::package) '~';
		case (self.visibility = UML::VisibilityKind::protected) '#';
		case (self.visibility = UML::VisibilityKind::private) '-';
		else '+';
	};
}

query UML::ObjectFlow::selectionLabelToString(label : UMLDI::SelectionLabel) : String {
	return replace('', self.selection(label), '«selection»\n<n>');
}

query UML::ObjectFlow::selection(label : UMLDI::UmlLabel) : String {
	return if self.selection->notEmpty() then self.selection.signature(label) endif;
}

query UML::ObjectFlow::transformationLabelToString(label : UMLDI::TransformationLabel) : String {
	return replace('', self._transformation(label), '«transformation»\n<n>');
}

query UML::ObjectFlow::_transformation(label : UMLDI::UmlLabel) : String {
	return if self._transformation->notEmpty() then self._transformation.signature(label) endif;
}

query UML::ObjectNode::constraintLabelToString(label : UMLDI::ConstraintLabel) : String {
	var s : OrderedSet(String);
	s += replaceIfNotEmpty(null, self.upperBound(label), 'upperBound=<n>');
	s += replaceIfNotEmpty(null, self.ordering(label), 'ordering=<n>');
	s += replaceIfNotEmpty(null, self.controlType(label), '<n>');
	return replace('', s->separate(), '{<n>}');
}

query UML::ObjectNode::selectionLabelToString(label : UMLDI::SelectionLabel) : String {
	return replace('', self.selection(label), '«selection»\n<n>');
}

query UML::ObjectNode::signature(label : UMLDI::UmlLabel) : String {
	var s := self.name(label);
	s := replaceIfNotEmpty(s, self.type(label), '<o>:<n>');
	s := replaceIfNotEmpty(s, self.inState(label), '<o>\n[<n>]');
	return s;
}

query UML::ObjectNode::inState(label : UMLDI::UmlLabel) : String {
	return self.inState.name(label)->separate();
}

query UML::ObjectNode::selection(label : UMLDI::UmlLabel) : String {
	return if not self.selection.oclIsUndefined() then self.selection.name(label) endif;
}

query UML::ObjectNode::upperBound(label : UMLDI::UmlLabel) : String {
	return if not self.upperBound.oclIsUndefined() then self.upperBound.signature(label) endif;
}

query UML::ObjectNode::ordering(label : UMLDI::UmlLabel) : String {
	return self.ordering.toString();
}

query UML::ObjectNode::controlType(label : UMLDI::UmlLabel) : String {
	return if self.isControlType then 'controlType' endif;
}

query UML::OpaqueBehavior::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'opaqueBehavior';
}

query UML::OpaqueBehavior::signature(label : UMLDI::UmlLabel) : String {
	var s := replaceIfNotEmpty('', self.body(label), '{<n>}');
	return replaceIfNotEmpty(s, self.name(label), '<n>');
}

query UML::OpaqueBehavior::body(label : UMLDI::UmlLabel) : String {
	return List{1..self.body->size()}->collect(i|self.body(i, label))->separate();
}

query UML::OpaqueBehavior::body(i : Integer, label : UMLDI::UmlLabel) : String {
	var lang := if i <= self.language->size() then self.language->at(i) else null endif;
	return replaceIfNotEmpty(self.body->at(i), lang, '{<n>} <o>');
}

query UML::OpaqueExpression::value(label : UMLDI::UmlLabel) : String {
	return List{1..self.body->size()}->collect(i|self.body(i, label))->separate();
}

query UML::OpaqueExpression::body(i : Integer, label : UMLDI::UmlLabel) : String {
	var lang := if i <= self.language->size() then self.language->at(i) else null endif;
	return replaceIfNotEmpty(self.body->at(i), lang, '{<n>} <o>');
}

query UML::Operation::basicSignature(label : UMLDI::UmlLabel) : String {
	return replace(self.name(label), self.parameters(label), '<o>(<n>)');
}

query UML::OperationTemplateParameter::parameteredElement(label : UMLDI::UmlLabel) : String {
	return if self.parameteredElement->notEmpty() and self.parameteredElement.oclIsKindOf(UML::Operation) then
		self.parameteredElement.oclAsType(UML::Operation).basicSignature(label)
	endif;
}

query UML::PackageImport::keywords(label : UMLDI::UmlLabel) : String {
	return 'import';
}

query UML::PackageMerge::keywords(label : UMLDI::UmlLabel) : String {
	return 'merge';
}

query UML::Parameter::signature(label : UMLDI::UmlLabel) : String {
	var s := self.name(label);
	s := replaceIfNotEmpty(s, self.direction(label), '<n> <o>');
	s := replaceIfNotEmpty(s, self.type(label), '<o>:<n>');
	s := replaceIfNotEmpty(s, self.multiplicity(label), '<o>[<n>]');
	return replaceIfNotEmpty(s, self.defaultValue(label), '<o>=<n>');
}

query UML::Parameter::direction(label : UMLDI::UmlLabel) : String {
	return switch {
		case (self.direction = UML::ParameterDirectionKind::_in) '';
		case (self.direction = UML::ParameterDirectionKind::_inout) 'inout';
		case (self.direction = UML::ParameterDirectionKind::_out) 'out';
		else 'return';
	};
}

query UML::Parameter::defaultValue(label : UMLDI::UmlLabel) : String {
	return if not self.defaultValue.oclIsUndefined() then self.defaultValue.signature(label) endif;
}

query UML::ParameterableElement::name(label : UMLDI::UmlLabel) : String {
	return if self.oclIsKindOf(UML::NamedElement) then
		self.oclAsType(UML::NamedElement).name(label)
	endif;
}

query UML::Port::signature(label : UMLDI::UmlLabel) : String {
	var s := self.name(label);
	s := replaceIfNotEmpty(s, self.derivation(label), '<n><o>');
	s := replaceIfNotEmpty(s, self.visibility(label), '<n><o>');
	s := replaceIfNotEmpty(s, self.type(label), '<o>:<n>');
	s := replaceIfNotEmpty(s, self.multiplicity(label), '<o>[<n>]');
	s := replaceIfNotEmpty(s, self.defaultValue(label), '<o>=<n>');
	return s;
}

query UML::PrimitiveType::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'primitive';
}

query UML::Profile::keywords(label : UMLDI::UmlLabel) : String {
	return 'profile';
}

query UML::ProfileApplication::keywords(label : UMLDI::UmlLabel) : String {
	return if self.isStrict then 'strict' else 'apply' endif;
}

query UML::Property::multiplicityLabelToString(label : UMLDI::MultiplicityLabel) : String {
	return self.multiplicity(label);
}

query UML::Property::roleLabelToString(label : UMLDI::RoleLabel) : String {
	return self.shortAttributeSignature(label);
}

query UML::Property::signature(label : UMLDI::UmlLabel) : String {
	return if label.owningUmlDiagramElement.oclIsKindOf(UMLDI::UmlEdge) then
		self.shortAttributeSignature(label)
	else
		self.longAttributeSignature(label)
	endif;
}

query UML::Property::listItemSignature(label : UMLDI::UmlLabel) : String {
	var compartment := label.owningUmlDiagramElement;
	return if compartment.oclIsKindOf(UMLDI::StereotypeCompartment) then
		self.taggedValueSignature(label)
	else
		self.longAttributeSignature(label)
	endif;
}

query UML::Property::shortAttributeSignature(label : UMLDI::UmlLabel) : String {
	var s := self.name(label);
	s := replaceIfNotEmpty(s, self.derivation(label), '<n><o>');
	s := replaceIfNotEmpty(s, self.visibility(label), '<n><o>');
	return s;
}

query UML::Property::longAttributeSignature(label : UMLDI::UmlLabel) : String {
	var s := self.name(label);
	s := replaceIfNotEmpty(s, self.derivation(label), '<n><o>');
	s := replaceIfNotEmpty(s, self.visibility(label), '<n><o>');
	s := replaceIfNotEmpty(s, self.type(label), '<o>:<n>');
	s := replaceIfNotEmpty(s, self.multiplicity(label), '<o>[<n>]');
	s := replaceIfNotEmpty(s, self.defaultValue(label), '<o>=<n>');
	return s;
}

query UML::Property::taggedValueSignature(label : UMLDI::UmlLabel) : String {
	var compartment := label.owningUmlDiagramElement.oclAsType(UMLDI::StereotypeCompartment);
	var stereotype := compartment.umlModelElement.oclAsType(UML::Stereotype);
	var element := compartment.owningUmlDiagramElement.umlModelElement.oclAsType(UML::Element);
	var value := element.getValue(stereotype, self.name).toString();
	return replace(self.name(label), value, '<o>=<n>');
}

query UML::Property::derivation(label : UMLDI::UmlLabel) : String {
	return if self.isDerived then '/' endif;
}

query UML::Property::defaultValue(label : UMLDI::UmlLabel) : String {
	return if not self.defaultValue.oclIsUndefined() then self.defaultValue.signature(label) endif;
}

query UML::ProtocolStateMachine::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'protocolStateMachine';
}

query UML::ProtocolStateMachine::nonClassifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'protocol';
}

query UML::ProtocolTransition::signature(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.trigger(label), '<n>/');
	s := replaceIfNotEmpty(s, self.preCondition(label), '[<n>] <o>');
	s := replaceIfNotEmpty(s, self.postCondition(label), '<o> [<n>]');
	s := replaceIfNotEmpty(s, self.final(label), '<o>\n{<n>}');
	return s;
}

query UML::ProtocolTransition::preCondition(label : UMLDI::UmlLabel) : String {
	return if self.preCondition->notEmpty() then 
		self.preCondition.specification(label)
	endif;
}

query UML::ProtocolTransition::postCondition(label : UMLDI::UmlLabel) : String {
	return if self.postCondition->notEmpty() then 
		self.postCondition.specification(label)
	endif;
}

query UML::Realization::keywords(label : UMLDI::UmlLabel) : String {
	return '';
}

query UML::Reception::keywords(label : UMLDI::UmlLabel) : String {
	return 'signal';
}

query UML::Region::signature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.name(label), self.extended(label), '<o>\n{<n>}')
}

query UML::Region::extended(label : UMLDI::UmlLabel) : String {
	return if self.extendedRegion->notEmpty() then
		'extended'
	endif;
}

query UML::Signal::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'signal';
}

query UML::SignalEvent::signature(label : UMLDI::UmlLabel) : String {
	return self.signal(label);
}

query UML::SignalEvent::signal(label : UMLDI::UmlLabel) : String {
	return if self.signal->notEmpty() then self.signal.name(label) endif;
}

query UML::Slot::signature(label : UMLDI::UmlLabel) : String {
	var s := self.feature(label);
	s := replaceIfNotEmpty(s, self.type(label), '<o>:<n>');
	s := replaceIfNotEmpty(s, self.value(label), '<o>=<n>');
	return s;
}

query UML::Slot::feature(label : UMLDI::UmlLabel) : String {
	return if self.definingFeature->notEmpty() then self.definingFeature.name(label) endif;
}

query UML::Slot::type(label : UMLDI::UmlLabel) : String {
	return if self.definingFeature->notEmpty() then self.definingFeature.type(label) endif;
}

query UML::Slot::value(label : UMLDI::UmlLabel) : String {
	return self.value.signature(label)->separate();
}

query UML::State::signature(label : UMLDI::UmlLabel) : String {
	var s := self.name(label);
	s := replaceIfNotEmpty(s, self.submachine(label), '<o>:<n>');
	s := replaceIfNotEmpty(s, self.extended(label), '<o>\n{<n>}');
	s := replaceIfNotEmpty(s, self.final(label), '<o>\n{<n>}');
	s := replaceIfNotEmpty(s, self.stateInvariant(label), '<o>\n[<n>]');
	return s;
}

query UML::State::submachine(label : UMLDI::UmlLabel) : String {
	return if self.submachine->notEmpty() then
		self.submachine.name(label)
	endif;
}

query UML::State::extended(label : UMLDI::UmlLabel) : String {
	return if self.isComposite and self.redefinedState->notEmpty() then
		'extended'
	endif;
}

query UML::State::final(label : UMLDI::UmlLabel) : String {
	return if self.isLeaf then
		'final'
	endif;
}

query UML::State::stateInvariant(label : UMLDI::UmlLabel) : String {
	return if self.stateInvariant->notEmpty() then
		self.stateInvariant.specification(label)
	endif;
}

query UML::StateInvariant::constraintLabelToString(label : UMLDI::ConstraintLabel) : String {
	return replace('', self.invariant(label), "{<n>}");
}

query UML::StateInvariant::signature(label : UMLDI::UmlLabel) : String {
	var shape := label.owningUmlDiagramElement.oclAsType(UMLDI::StateInvariantShape);
	return if shape.useStateShape then
		self.invariant(label)
	else
		replace('', self.invariant(label), "{<n>}")
	endif;
}

query UML::StateInvariant::invariant(label : UMLDI::UmlLabel) : String {
	return if self.invariant->notEmpty() then self.invariant.specification(label) endif;
}

mapping UML::StateMachine::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	var shape := label.owningUmlDiagramElement.oclAsType(UMLDI::StateMachineShape);
	if  label.oclIsKindOf(UMLDI::MainLabel) and not shape.useClassifierNotation then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::StateMachine::signature(label : UMLDI::UmlLabel) : String {
	var owner := label.owningDiagramElement.oclAsType(UMLDI::StateMachineShape);
	return if owner.useClassifierNotation then
		self.name(label)
	else
		replaceIfNotEmpty(self.name(label), self.extended(label), '<o>\n{<n>}')
	endif;
}

query UML::StateMachine::extended(label : UMLDI::UmlLabel) : String {
	return if self.extendedStateMachine->notEmpty() then
		'extended'
	endif;
}

query UML::StateMachine::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'stateMachine';
}

query UML::Stereotype::classifierShapeKeywords(label : UMLDI::UmlLabel) : String {
	return 'stereotype';
}

mapping UML::StructuredActivityNode::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if label.oclIsKindOf(UMLDI::MainLabel) then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::StructuredActivityNode::keywords(label : UMLDI::UmlLabel) : String {
	return 'structured';
}

query UML::Substitution::keywords(label : UMLDI::UmlLabel) : String {
	return 'substitute';
}

query UML::TemplateBinding::keywords(label : UMLDI::UmlLabel) : String {
	return 'bind';
}

query UML::TemplateBinding::signature(label : UMLDI::UmlLabel) : String {
	return self.substitutions(label);
}

query UML::TemplateBinding::substitutions(label : UMLDI::UmlLabel) : String {
	return self.parameterSubstitution.signature(label)->separate();
}

query UML::TemplateParameter::signature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.parameteredElement(label), self.metaclass(label), '<o>:<n>');
}

query UML::TemplateParameter::parameteredElement(label : UMLDI::UmlLabel) : String {
	return if self.parameteredElement->notEmpty() then self.parameteredElement.name(label) endif;
}

query UML::TemplateParameter::metaclass(label : UMLDI::UmlLabel) : String {
	return if self.parameteredElement->notEmpty() then
		self.parameteredElement.metaClassName()
	endif;
}

query UML::TemplateParameterSubstitution::signature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.formal(label), self.actual(label), '<o>-><n>');
}

query UML::TemplateParameterSubstitution::formal(label : UMLDI::UmlLabel) : String {
	return if self.formal->notEmpty() then self.formal.parameteredElement(label) endif;
}

query UML::TemplateParameterSubstitution::actual(label : UMLDI::UmlLabel) : String {
	return if self.actual->notEmpty() then self.actual.name(label) endif;
}

query UML::TimeEvent::signature(label : UMLDI::UmlLabel) : String {
	return if self.isRelative then
		replaceIfNotEmpty('', self._when(label), 'after <n>')
	else
		replaceIfNotEmpty('', self._when(label), 'at <n>')
	endif;
}

query UML::TimeEvent::_when(label : UMLDI::UmlLabel) : String {
	return if not self._when.oclIsUndefined() then self._when.signature(label) endif;
}

query UML::TimeExpression::value(label : UMLDI::UmlLabel) : String {
	return if self.expr->notEmpty() then 
		self.expr.signature(label) 
	else
		self.observation.signature(label)->separate()
	endif;
}

query UML::Transition::signature(label : UMLDI::UmlLabel) : String {
	var s := self.trigger(label);
	s := replaceIfNotEmpty(s, self.guard(label), '<o>[<n>]');
	s := replaceIfNotEmpty(s, self.effect(label), '<o>/<n>');
	s := replaceIfNotEmpty(s, self.final(label), '<o>\n{<n>}');
	return s;
}

query UML::Transition::trigger(label : UMLDI::UmlLabel) : String {
	return self.trigger.signature(label)->separate();
}

query UML::Transition::guard(label : UMLDI::UmlLabel) : String {
	return if self.guard->notEmpty() then self.guard.specification(label) endif;
}

query UML::Transition::effect(label : UMLDI::UmlLabel) : String {
	return if self.effect->notEmpty() then self.effect.signature(label) endif;
}

query UML::Transition::final(label : UMLDI::UmlLabel) : String {
	return if self.isLeaf then 'final' endif;
}

query UML::Trigger::signature(label : UMLDI::UmlLabel) : String {
	return self.event(label);
}

query UML::Trigger::listItemSignature(label : UMLDI::UmlLabel) : String {
	return replace('', self.signature(label), '<n>/defer')
}

query UML::Trigger::event(label : UMLDI::UmlLabel) : String {
	return if self.event->notEmpty() then self.event.signature(label) endif;
}

query UML::TypedElement::type(label : UMLDI::UmlLabel) : String {
	return if not self.type.oclIsUndefined() then self.type.name(label) endif;
}

query UML::Usage::keywords(label : UMLDI::UmlLabel) : String {
	return 'use';
}

query UML::ValueSpecification::signature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.name(label), self.value(label), '<n>');
}

query UML::ValueSpecification::value(label : UMLDI::UmlLabel) : String {
	return null;
}

query UML::ValueSpecification::inputSignature(label : UMLDI::UmlLabel) : String {
	return replaceIfNotEmpty(self.inputValue(label), self.name(label), '<n>=<o>');
}

query UML::ValueSpecification::outputSignature(label : UMLDI::UmlLabel) : String {
	var s := replaceIfNotEmpty(self.name(label), self.outputValue(label), '<o>:<n>');
	return replaceIfNotEmpty(s, self.assignmentTarget(label), '<n>=<o>');
}

query UML::ValueSpecification::inputValue(label : UMLDI::UmlLabel) : String {
	return self.signature(label);
}

query UML::ValueSpecification::outputValue(label : UMLDI::UmlLabel) : String {
	return self.signature(label);
}

query UML::ValueSpecification::assignmentTarget(label : UMLDI::UmlLabel) : String {
	return null;	
}
