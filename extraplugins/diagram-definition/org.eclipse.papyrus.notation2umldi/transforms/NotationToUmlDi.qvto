/**
 * Copyright (c) 2014 CEA LIST.
 *  
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 * Contributors:
 *  CEA LIST - Initial API and implementation
 */
import NotationIds;

modeltype DC uses "http://www.omg.org/spec/DD/20110901/DC";
modeltype DI uses "http://www.omg.org/spec/DD/20110901/DI";
modeltype UMLDI uses "http://www.omg.org/spec/UML/20131001/UMLDI";
modeltype Notation uses "http://www.eclipse.org/gmf/runtime/1.0.2/notation";
modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";
modeltype Style uses "http://www.eclipse.org/papyrus/infra/viewpoints/policy/style";
modeltype Configuration uses "http://www.eclipse.org/papyrus/infra/viewpoints/configuration";
	
transformation NotationToUmlDi(in notation : Notation, out UMLDI);

main() {
	notation.rootObjects()[Notation::Diagram]->sortedBy(name)->forEach(diagram) {
		renderDiagram(diagram);
		diagram.map toUmlDiagram();
		disposeDiagram(diagram);
	}
}

mapping Notation::Diagram::toUmlDiagram() : UMLDI::UmlDiagram
	disjuncts Notation::Diagram::diagramToPackageDiagram,
			  Notation::Diagram::diagramToClassDiagram,
			  Notation::Diagram::diagramToComponentDiagram,
			  Notation::Diagram::diagramToCompositeStructureDiagram,
			  Notation::Diagram::diagramToDeploymentDiagram,
			  Notation::Diagram::diagramToProfileDiagram,
			  Notation::Diagram::diagramToUseCaseDiagram,
			  Notation::Diagram::diagramToStateMachineDiagram,
			  Notation::Diagram::diagramToActivityDiagram,
			  Notation::Diagram::diagramToSequenceDiagram,
			  Notation::Diagram::diagramToCommunicationDiagram,
			  Notation::Diagram::diagramToTimingDiagram,
			  Notation::Diagram::diagramToInteractionOverviewDiagram;

abstract mapping Notation::View::viewToUmlDiagramElement() : UMLDI::UmlDiagramElement 
{
	umlModelElement := self.element.oclAsType(UML::Element);
}

abstract mapping Notation::Diagram::diagramToUmlDiagram() : UMLDI::UmlDiagram 
	inherits Notation::View::viewToUmlDiagramElement
{
	name := self.name;
	topUmlDiagramElement += self.visibleChildren()->map toTopUmlDiagramElement();	
	topUmlDiagramElement += self.visibleEdges()->map toTopUmlDiagramElement();
	
	// look for applied stereotype comments and add them as sterotype labels
	self.edges->select(e|getViewType(e) = appliedStereotypeEdgeType)->forEach(e) {
		var topUmlDiagramElement := e.source.resolveone(UMLDI::TopUmlDiagramElement);
		var stereotypeLabel := e.target.oclAsType(Notation::Node).map nodeToStereotypeLabel();
		topUmlDiagramElement.stereotypeLabel := stereotypeLabel;
	};
}

mapping Notation::Diagram::diagramToClassDiagram() : UMLDI::ClassDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = classDiagramType };

mapping Notation::Diagram::diagramToPackageDiagram() : UMLDI::PackageDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = classDiagramType and 
		   self.styles![Style::PapyrusViewStyle]._configuration.name = packageDiagramType };

mapping Notation::Diagram::diagramToProfileDiagram() : UMLDI::ProfileDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = profileDiagramType };

mapping Notation::Diagram::diagramToComponentDiagram() : UMLDI::ComponentDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = componentDiagramType };

mapping Notation::Diagram::diagramToCompositeStructureDiagram() : UMLDI::CompositeStructureDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = compositeStructureDiagramType };

mapping Notation::Diagram::diagramToDeploymentDiagram() : UMLDI::DeploymentDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = deploymentDiagramType };

mapping Notation::Diagram::diagramToUseCaseDiagram() : UMLDI::UseCaseDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = useCaseDiagramType };

mapping Notation::Diagram::diagramToStateMachineDiagram() : UMLDI::StateMachineDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = stateMachineDiagramType };

mapping Notation::Diagram::diagramToActivityDiagram() : UMLDI::ActivityDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = activityDiagramType }
{
	// convert local pre/post condition shapes into labels
	self.edges->select(e|getViewType(e) = attachmentEdgeType and 
		e.target.element.oclIsKindOf(UML::Constraint) and 
			e.target.element.container() = e.source.element)->forEach(e) {
		var actionShape := e.source.oclAsType(Notation::Node).resolveone(UMLDI::ActionShape); 	
		actionShape.conditionLabel += e.target.oclAsType(Notation::Node).map nodeToConstraintLabel();
	}
	
}

mapping Notation::Diagram::diagramToSequenceDiagram() : UMLDI::SequenceDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = sequenceDiagramType }
{
	var children := self->closure(children)->select(oclIsKindOf(Notation::Shape) and element.oclIsKindOf(UML::TimeConstraint));
	var compartment := result.ownedDiagramElement![UMLDI::InteractionShape].subfragmentCompartment;
	children->forEach(c) {
		var shape := c.oclAsType(Notation::Shape).map toTopUmlDiagramElement().oclAsType(UMLDI::UmlShape);
		compartment.topUmlDiagramElement += shape;
	};	
}

mapping Notation::Diagram::diagramToCommunicationDiagram() : UMLDI::CommunicationDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = communicationDiagramType };

mapping Notation::Diagram::diagramToTimingDiagram() : UMLDI::TimingDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = timingDiagramType }
{
	var children := self->closure(children)->select(oclIsKindOf(Notation::Shape) and 
		(element.oclIsKindOf(UML::IntervalConstraint) or element.oclIsKindOf(UML::Observation)));
	var compartment := result.ownedDiagramElement![UMLDI::InteractionShape].subfragmentCompartment;
	children->forEach(c) {
		var shape := c.oclAsType(Notation::Shape).map toTopUmlDiagramElement().oclAsType(UMLDI::UmlShape);
		compartment.topUmlDiagramElement += shape;
	};
}

mapping Notation::Diagram::diagramToInteractionOverviewDiagram() : UMLDI::InteractionOverviewDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = interactionOverviewDiagramType };

//-------------------------------------------------------------------------------------

abstract mapping Notation::View::viewToTopUmlDiagramElement() : UMLDI::TopUmlDiagramElement 
	inherits Notation::View::viewToUmlDiagramElement
{
	showStereotypeAttributes := self.eAnnotations.details->any(key='StereotypePropertyLocation').value = 'With brace';

	var label := self.visibleChildren()->selectOne(c|getViewType(c) = nameLabelType);
	mainLabel := label.map nodeToMainLabel();
}

mapping Notation::View::toTopUmlDiagramElement() : UMLDI::TopUmlDiagramElement {
	init {
		// do nothing
	}
}

//-------------------------------------------------------------------------------------

mapping Notation::Shape::toTopUmlDiagramElement() : UMLDI::TopUmlDiagramElement
	disjuncts Notation::Shape::shapeToTimeExpressionShape,
			  Notation::Shape::shapeToDurationShape,
			  Notation::Shape::shapeToRegionShape,
			  Notation::Shape::shapeToStateShape,
			  Notation::Shape::shapeToPseudostateShape,
			  Notation::Shape::shapeToAssociationClassShape,
			  Notation::Shape::shapeToUseCaseShape,
			  Notation::Shape::shapeToActorShape,
			  Notation::Shape::shapeToComponentShape,
			  Notation::Shape::shapeToStereotypeShape,
			  Notation::Shape::shapeToProtocolStateMachineShape,
			  Notation::Shape::shapeToConnectionPointReferenceShape,
			  Notation::Shape::shapeToStateMachineShape,
			  Notation::Shape::shapeToActivityShape,
			  Notation::Shape::shapeToInteractionShape,
			  Notation::Shape::shapeToFunctionBehaviorShape,
			  Notation::Shape::shapeToOpaqueBehaviorShape,
			  Notation::Shape::shapeToExecutionEnvironmentShape,
			  Notation::Shape::shapeToDeviceShape,
			  Notation::Shape::shapeToNodeShape,
			  Notation::Shape::shapeToClassShape,
			  Notation::Shape::shapeToAssociationShape,
			  Notation::Shape::shapeToDependencyShape,
			  Notation::Shape::shapeToInterfaceShape,
			  Notation::Shape::shapeToPrimitiveTypeShape,
			  Notation::Shape::shapeToEnumerationShape,
			  Notation::Shape::shapeToDataTypeShape,
			  Notation::Shape::shapeToDeploymentSpecificationShape,
			  Notation::Shape::shapeToArtifactShape,
			  Notation::Shape::shapeToSignalShape,
			  Notation::Shape::shapeToCollaborationShape,
			  Notation::Shape::shapeToCollaborationUseShape,
			  Notation::Shape::shapeToPropertyShape,
			  Notation::Shape::shapeToProfileShape,
			  Notation::Shape::shapeToModelShape,
			  Notation::Shape::shapeToPackageShape,
			  Notation::Shape::shapeToTimeConstraintShape,
			  Notation::Shape::shapeToDurationConstraintShape,
			  Notation::Shape::shapeToConstraintShape,
			  Notation::Shape::shapeToCommentShape,
			  Notation::Shape::shapeToInformationItemShape,
			  Notation::Shape::shapeToInstanceSpecificationShape,
			  Notation::Shape::shapeToTimeObservationShape,
			  Notation::Shape::shapeToDurationObservationShape,
			  Notation::Shape::shapeToPortShape,
			  Notation::Shape::shapeToExpansionRegionShape,
			  Notation::Shape::shapeToStructuredActivityNodeShape,
			  Notation::Shape::shapeToActionShape,
			  Notation::Shape::shapeToActivityParameterNodeShape,
			  Notation::Shape::shapeToPinShape,
			  Notation::Shape::shapeToExpansionNodeShape,
			  Notation::Shape::shapeToObjectNodeShape,
			  Notation::Shape::shapeToActivityNodeShape,
			  Notation::Shape::shapeToActivityPartitionShape,
			  Notation::Shape::shapeToActivityGroupShape,
			  Notation::Shape::shapeToGateShape,
			  Notation::Shape::shapeToLifelineShape,
			  Notation::Shape::shapeToInteractionUseShape,
			  Notation::Shape::shapeToCombinedFragmentShape,
			  Notation::Shape::shapeToInteractionOperandShape,
			  Notation::Shape::shapeToStateInvariantShape,
			  Notation::Shape::shapeToDestructionOccurrenceSpecificationShape,
			  Notation::Shape::shapeToInteractionFragmentShape;

abstract mapping Notation::Shape::shapeToUmlShape() : UMLDI::UmlShape
	inherits Notation::View::viewToTopUmlDiagramElement
{
	bounds := self.bounds();
	localUmlStyle := object UMLDI::UmlStyle {
		fontName := self.fontName;
		fontSize := self.fontHeight;
	};
	
	if self.eAnnotations.details->any(key='StereotypePropertyLocation').value = 'Compartment' then {
		self.transientChildren->select(c|c.visible and getViewType(c) = appliedStereotypeCompartmentType)->forEach(c) {
			var i := self.transientChildren->indexOf(c);
			var s := self.eAnnotations.details->any(key='StereotypeList').value.tokenize(',')->at(i);
			var e := self.element.oclAsType(UML::Element).getAppliedStereotype(s);
			var compartment := c.map nodeToStereotypeCompartment();
			compartment.umlModelElement := e;
			stereotypeCompartment += compartment;
		};
	} endif;
}

abstract mapping Notation::Shape::shapeToElementShape() : UMLDI::ElementShape
	inherits Notation::Shape::shapeToUmlShape;

abstract mapping Notation::Shape::shapeToTemplatableElementShape() : UMLDI::TemplateableElementShape
	inherits Notation::Shape::shapeToElementShape
{
	var signature = self.visibleChildren()->selectOne(element.oclIsKindOf(UML::TemplateSignature));
	if (signature->notEmpty()) {
		var compartment = signature.visibleChildren()->selectOne(c|getViewType(c) = templateParameterCompartmentType);
		templateParameterCompartment := compartment.map nodeToTemplateParameterCompartment();
	}
}

abstract mapping Notation::Shape::shapeToElementWithPackagedElementsShape() : UMLDI::ElementWithPackagedElementsShape
	inherits Notation::Shape::shapeToElementShape
{
	var compartment = self.visibleChildren()->selectOne(c|packagedElementCompartmentType->includes(getViewType(c)));
	packagedElementCompartment := compartment.map nodeToPackagedElementCompartment();
}

abstract mapping Notation::Shape::shapeToElementWithStructureShape() : UMLDI::ElementWithStructureShape
	inherits Notation::Shape::shapeToElementShape
{
	var compartment = self.visibleChildren()->selectOne(c|internalStructueCompartmentType->includes(getViewType(c)));
	structureCompartment := compartment.map nodeToStructureCompartment();
}

abstract mapping Notation::Shape::shapeToElementWithPortsShape() : UMLDI::ElementWithPortsShape
	inherits Notation::Shape::shapeToElementWithStructureShape
{
	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::Port));
	portShape += children.oclAsType(Notation::Shape)->map shapeToPortShape();	
}

abstract mapping Notation::Shape::shapeToClassifierShape() : UMLDI::ClassifierShape
	inherits Notation::Shape::shapeToTemplatableElementShape
{
	useClassifierNotation := customShapeType->excludes(getViewType(self));
	
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = useCaseCompartmentType);
	ownedUseCaseCompartment := compartment.map nodeToOwnedUseCaseCompartment();
}

abstract mapping Notation::Shape::shapeToClassifierWithAttributesShape() : UMLDI::ClassifierWithAttributesShape
	inherits Notation::Shape::shapeToClassifierShape
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = attributeCompartmentType);
	attributeCompartment := compartment.map nodeToAttributeCompartment();
}

abstract mapping Notation::Shape::shapeToClassifierWithOperationsShape() : UMLDI::ClassifierWithOperationsShape
	inherits Notation::Shape::shapeToClassifierWithAttributesShape
{
	var compartment := self.visibleChildren()->selectOne(c|getViewType(c) = operationCompartmentType);
	if (compartment.visibleChildren()->isEmpty() or compartment.visibleChildren()->forAll(element.oclIsKindOf(UML::Operation))) {
		operationCompartment := compartment.map nodeToOperationCompartment()
	};
}

abstract mapping Notation::Shape::shapeToDeploymentTargetShape() : UMLDI::DeploymentTargetShape
	inherits Notation::Shape::shapeToElementShape;

abstract mapping Notation::Shape::shapeToClassifierWithNestedClassifiersShape() : UMLDI::ClassifierWithNestedClassifiersShape
	inherits Notation::Shape::shapeToClassifierWithReceptionsShape
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = nestedClassifierCompartmentType);
	nestedClassifierCompartment := compartment.map nodeToNestedClassifierCompartment();
}

abstract mapping Notation::Shape::shapeToClassifierWithReceptionsShape() : UMLDI::ClassifierWithReceptionsShape 
	inherits  Notation::Shape::shapeToClassifierWithOperationsShape
{
	var compartment := self.visibleChildren()->selectOne(c|getViewType(c) = operationCompartmentType);
	if (compartment.visibleChildren()->notEmpty() and compartment.visibleChildren()->forAll(element.oclIsKindOf(UML::Reception))) {
		receptionCompartment := compartment.map nodeToReceptionCompartment()
	};
}

abstract mapping Notation::Shape::shapeToBehavioredClassifierShape() : UMLDI::BehavioredClassifierShape 
	inherits  Notation::Shape::shapeToClassifierShape
{
}

abstract mapping Notation::Shape::shapeToBaseStateShape() : UMLDI::BaseStateShape 
	inherits  Notation::Shape::shapeToElementShape
{
	var compartment = self.visibleChildren()->selectOne(c|regionCompartmentType->includes(getViewType(c)));
	regionCompartment := compartment.map nodeToRegionCompartment();

	var children = self.visibleChildren()->select(isConnectionPoint());
	connectionPointShape += children.oclAsType(Notation::Shape)->map shapeToPseudostateShape();	
}

query Notation::Node::isConnectionPoint() : Boolean {
	return self.element.oclIsKindOf(UML::Pseudostate) and self.element.oclAsType(UML::Pseudostate)->
		exists(kind = UML::PseudostateKind::entryPoint or kind = UML::PseudostateKind::exitPoint);
}

mapping Notation::Shape::shapeToClassShape() : UMLDI::ClassShape
	inherits Notation::Shape::shapeToClassifierWithNestedClassifiersShape, 
	         Notation::Shape::shapeToElementWithPortsShape,
	         Notation::Shape::shapeToBehavioredClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Class) };

mapping Notation::Shape::shapeToCollaborationShape() : UMLDI::CollaborationShape
	inherits Notation::Shape::shapeToClassifierWithOperationsShape, 
	 		 Notation::Shape::shapeToElementWithStructureShape,
	 		 Notation::Shape::shapeToBehavioredClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Collaboration) };

mapping Notation::Shape::shapeToUseCaseShape() : UMLDI::UseCaseShape
	 inherits Notation::Shape::shapeToBehavioredClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::UseCase) }
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = extensionPointCompartmentType);
	extensionPointCompartment := compartment.map nodeToExtensionPointCompartment();
}

mapping Notation::Shape::shapeToActorShape() : UMLDI::ActorShape
	 inherits Notation::Shape::shapeToBehavioredClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Actor) };

mapping Notation::Shape::shapeToCollaborationUseShape() : UMLDI::CollaborationUseShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::CollaborationUse) };

mapping Notation::Shape::shapeToPropertyShape() : UMLDI::PropertyShape
	inherits Notation::Shape::shapeToElementWithPortsShape, Notation::Shape::shapeToDeploymentTargetShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Property) and getViewType(self) <> roleBindingShapeType};

mapping Notation::Shape::shapeToComponentShape() : UMLDI::ComponentShape
	inherits Notation::Shape::shapeToClassShape, Notation::Shape::shapeToElementWithPackagedElementsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Component) };

mapping Notation::Shape::shapeToAssociationClassShape() : UMLDI::AssociationClassShape
	inherits Notation::Shape::shapeToClassShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::AssociationClass) };

mapping Notation::Shape::shapeToInformationItemShape() : UMLDI::InformationItemShape
	inherits Notation::Shape::shapeToClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InformationItem) };

mapping Notation::Shape::shapeToInterfaceShape() : UMLDI::InterfaceShape
	inherits Notation::Shape::shapeToClassifierWithNestedClassifiersShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Interface) };
	
mapping Notation::Shape::shapeToDataTypeShape() : UMLDI::DataTypeShape
	inherits Notation::Shape::shapeToClassifierWithOperationsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::DataType) };

mapping Notation::Shape::shapeToArtifactShape() : UMLDI::ArtifactShape
	inherits Notation::Shape::shapeToClassifierWithOperationsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Artifact) }
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = nestedArtifactCompartmentType);
	nestedArtifactCompartment := compartment.map nodeToNestedArtifactCompartment();
}

mapping Notation::Shape::shapeToDeploymentSpecificationShape() : UMLDI::DeploymentSpecificationShape
	inherits Notation::Shape::shapeToArtifactShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::DeploymentSpecification) };

mapping Notation::Shape::shapeToTimeObservationShape() : UMLDI::TimeObservationShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::TimeObservation) }
{
	if result.mainLabel->notEmpty() then {
		result.bounds.x := result.mainLabel.bounds.x;
		result.bounds.y := result.mainLabel.bounds.y;
		result.bounds.width := result.mainLabel.bounds.width;
		result.bounds.height := result.mainLabel.bounds.height;
	} endif;
}

mapping Notation::Shape::shapeToDurationObservationShape() : UMLDI::DurationObservationShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::DurationObservation) };

mapping Notation::Shape::shapeToPrimitiveTypeShape() : UMLDI::PrimitiveTypeShape
	inherits Notation::Shape::shapeToDataTypeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::PrimitiveType) };

mapping Notation::Shape::shapeToSignalShape() : UMLDI::SignalShape
	inherits Notation::Shape::shapeToClassifierWithAttributesShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Signal) };

mapping Notation::Shape::shapeToEnumerationShape() : UMLDI::EnumerationShape
	inherits Notation::Shape::shapeToClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Enumeration) }
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = literalCompartmentType);
	literalCompartment := compartment.map nodeToLiteralCompartment();
}

mapping Notation::Shape::shapeToPackageShape() : UMLDI::PackageShape
	inherits Notation::Shape::shapeToTemplatableElementShape, Notation::Shape::shapeToElementWithPackagedElementsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Package) };

mapping Notation::Shape::shapeToModelShape() : UMLDI::ModelShape
	inherits Notation::Shape::shapeToPackageShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Model) };

mapping Notation::Shape::shapeToProfileShape() : UMLDI::ProfileShape
	inherits Notation::Shape::shapeToPackageShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Profile) };

mapping Notation::Shape::shapeToConstraintShape() : UMLDI::ConstraintShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Constraint) }
{
	if result.mainLabel->notEmpty() then {
		result.mainLabel.bounds.x := result.bounds.x+1;
		result.mainLabel.bounds.y := result.bounds.y+1;
		result.mainLabel.bounds.width := result.bounds.width-10;
		result.mainLabel.bounds.height := result.bounds.height-10;
	} endif;
}

mapping Notation::Shape::shapeToTimeExpressionShape() : UMLDI::TimeExpressionShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::TimeExpression) };

mapping Notation::Shape::shapeToDurationShape() : UMLDI::DurationShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Duration) };

mapping Notation::Shape::shapeToCommentShape() : UMLDI::CommentShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Comment) };

mapping Notation::Shape::shapeToInstanceSpecificationShape() : UMLDI::InstanceSpecificationShape
	inherits Notation::Shape::shapeToDeploymentTargetShape 
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InstanceSpecification) }
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = slotCompartmentType);
	slotCompartment := compartment.map nodeToSlotCompartment();
}

mapping Notation::Shape::shapeToAssociationShape() : UMLDI::AssociationShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Association) }
{
	useClassifierNotation := false;
}

mapping Notation::Shape::shapeToDependencyShape() : UMLDI::DependencyShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Dependency) }
{
	bounds.width := 4;		
	bounds.height := 4;		
}

mapping Notation::Shape::shapeToPortShape() : UMLDI::PortShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Port) };

mapping Notation::Shape::shapeToStereotypeShape() : UMLDI::StereotypeShape
	inherits Notation::Shape::shapeToClassShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Stereotype) };

mapping Notation::Shape::shapeToNodeShape() : UMLDI::NodeShape
	inherits Notation::Shape::shapeToClassShape, Notation::Shape::shapeToDeploymentTargetShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Node) }
{
	var compartment = self.visibleChildren()->selectOne(c|nestedNodeCompartmentType->includes(getViewType(c)));
	if (compartment->notEmpty()) {
		if (compartment.visibleChildren()->isEmpty())
			nestedNodeCompartment := compartment.map nodeToNestedNodeCompartment()
		else if (compartment.visibleChildren()->forAll(c|c.element.oclIsKindOf(UML::Node)))
			nestedNodeCompartment := compartment.map nodeToNestedNodeCompartment()
		else if (compartment.visibleChildren()->forAll(c|c.element.oclIsKindOf(UML::Artifact)))
			nestedClassifierCompartment := compartment.map nodeToNestedClassifierCompartment()
	};
}

mapping Notation::Shape::shapeToDeviceShape() : UMLDI::DeviceShape
	inherits Notation::Shape::shapeToNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Device) };

mapping Notation::Shape::shapeToExecutionEnvironmentShape() : UMLDI::ExecutionEnvironmentShape
	inherits Notation::Shape::shapeToNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ExecutionEnvironment) };

mapping Notation::Shape::shapeToActivityShape() : UMLDI::ActivityShape
	inherits Notation::Shape::shapeToClassShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Activity) }
{
	result.mainLabel.bounds.x := result.bounds.x + 1;
	result.mainLabel.bounds.y := result.mainLabel.bounds.y + 1;

	var compartment := self.visibleChildren()->selectOne(c|getViewType(c) = parameterCompartmentType);
	parameterCompartment := compartment.map nodeToParameterCompartment();

	compartment := self.visibleChildren()->selectOne(c|getViewType(c) = preConditionCompartmentType);
	preConditionCompartment := compartment.map nodeToPreConditionCompartment();

	compartment := self.visibleChildren()->selectOne(c|getViewType(c) = postConditionCompartmentType);
	postConditionCompartment := compartment.map nodeToPostConditionCompartment();

	compartment := self.visibleChildren()->selectOne(c|activityNodeCompartmentType->includes(getViewType(c)));
	if compartment.children.element->exists(oclIsKindOf(Activity)) and not compartment.children.element->exists(oclIsKindOf(ActivityNode)) then
		ownedBehaviorCompartment := compartment.map nodeToOwnedBehaviorCompartment()
	else
		activityNodeCompartment := compartment.map nodeToActivityNodeCompartment()
	endif;

	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::ActivityParameterNode));
	activityParameterNodeShape += children.oclAsType(Notation::Shape)->map shapeToActivityParameterNodeShape();	
}

mapping Notation::Shape::shapeToInteractionShape() : UMLDI::InteractionShape
	inherits Notation::Shape::shapeToClassShape, 
			 Notation::Shape::shapeToInteractionFragmentWithSubfragmentsShape,
			 Notation::Shape::shapeToInteractionFragmentWithGatesShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Interaction) };

mapping Notation::Shape::shapeToStateMachineShape() : UMLDI::StateMachineShape
	inherits Notation::Shape::shapeToClassShape, Notation::Shape::shapeToBaseStateShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::StateMachine) }
{
	result.mainLabel.bounds.x := result.bounds.x + 1;
	result.mainLabel.bounds.y := result.mainLabel.bounds.y + 1;
}

mapping Notation::Shape::shapeToProtocolStateMachineShape() : UMLDI::ProtocolStateMachineShape
	inherits Notation::Shape::shapeToStateMachineShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ProtocolStateMachine) };

mapping Notation::Shape::shapeToOpaqueBehaviorShape() : UMLDI::OpaqueBehaviorShape
	inherits Notation::Shape::shapeToClassShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::OpaqueBehavior) };

mapping Notation::Shape::shapeToFunctionBehaviorShape() : UMLDI::FunctionBehaviorShape
	inherits Notation::Shape::shapeToOpaqueBehaviorShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::FunctionBehavior) };

mapping Notation::Shape::shapeToPseudostateShape() : UMLDI::PseudostateShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Pseudostate) };

mapping Notation::Shape::shapeToRegionShape() : UMLDI::RegionShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Region) }
{
	var key : String = self.eAnnotations->select(source='RegionAnnotationKey').details->at(1).value;
	key.characters()->forEach(c) {
		placement += switch {
			case (c = 'T') UMLDI::Placement::top; 
			case (c = 'R') UMLDI::Placement::right; 
			case (c = 'B') UMLDI::Placement::bottom; 
			case (c = 'L') UMLDI::Placement::left; 
		}
	};

	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = subvertexCompartmentType);
	subvertexCompartment := compartment.map nodeToSubvertexCompartment();
}

mapping Notation::Shape::shapeToStateShape() : UMLDI::StateShape
	inherits Notation::Shape::shapeToBaseStateShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::State) }
{
	if self.children->exists(element.oclIsKindOf(Behavior)) then
		internalBehaviorCompartment := self.map nodeToInternalBehaviorCompartment() 
	endif;

	if self.children->exists(element.oclIsKindOf(Transition)) then
		internalTransitionCompartment := self.map nodeToInternalTransitionCompartment() 
	endif;

	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::ConnectionPointReference));
	connectionPointReferenceShape += children.oclAsType(Notation::Shape)->map shapeToConnectionPointReferenceShape();	
}

mapping Notation::Shape::shapeToConnectionPointReferenceShape() : UMLDI::ConnectionPointReferenceShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ConnectionPointReference) };

mapping Notation::Shape::shapeToActivityGroupShape() : UMLDI::ActivityGroupShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ActivityGroup) };

mapping Notation::Shape::shapeToActivityPartitionShape() : UMLDI::ActivityPartitionShape
	inherits Notation::Shape::shapeToActivityGroupShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ActivityPartition) }
{
	var label := self.visibleChildren()->selectOne(c|subpartitionCompartmentType->includes(getViewType(c)));
	subpartitionCompartment := label.map nodeToSubpartitionCompartment();
}

mapping Notation::Shape::shapeToActivityNodeShape() : UMLDI::ActivityNodeShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ActivityNode) };

mapping Notation::Shape::shapeToObjectNodeShape() : UMLDI::ObjectNodeShape
	inherits Notation::Shape::shapeToActivityNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ObjectNode) }
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = constraintLabelType);
	constraintLabel := label.map nodeToConstraintLabel();

	label := self.visibleChildren()->selectOne(c|getViewType(c) = selectionLabelType);
	selectionLabel := label.map nodeToSelectionLabel();
}

mapping Notation::Shape::shapeToActivityParameterNodeShape() : UMLDI::ActivityParameterNodeShape
	inherits Notation::Shape::shapeToObjectNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ActivityParameterNode) };

mapping Notation::Shape::shapeToPinShape() : UMLDI::PinShape
	inherits Notation::Shape::shapeToObjectNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Pin) };

mapping Notation::Shape::shapeToExpansionNodeShape() : UMLDI::ExpansionNodeShape
	inherits Notation::Shape::shapeToObjectNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ExpansionNode) };

mapping Notation::Shape::shapeToActionShape() : UMLDI::ActionShape
	inherits Notation::Shape::shapeToActivityNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Action) }
{
	if self.element.oclIsKindOf(AcceptEventAction) then {
		var e := self.element.oclAsType(AcceptEventAction);
		if e.trigger->size() = 1 and e.trigger->any(true).event.oclIsKindOf(UML::TimeEvent) then {
			result.bounds.x := result.bounds.x + result.bounds.width/2 - 5; 
			result.bounds.width := 20; 
			result.bounds.height := if result.mainLabel->isEmpty() then 
				20 
			else 
				result.mainLabel.bounds.y - result.bounds.y - 5
			endif; 
		} endif;
	} endif;
	
	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::Pin));
	pinShape += children.oclAsType(Notation::Shape)->map shapeToPinShape();
}

abstract mapping Notation::Shape::shapeToElementWithActivityNodesShape() : UMLDI::ElementWithActivityNodesShape
	inherits Notation::Shape::shapeToElementShape
{
	var label := self.visibleChildren()->selectOne(c|activityNodeCompartmentType->includes(getViewType(c)));
	activityNodeCompartment := label.map nodeToActivityNodeCompartment();
	localUmlStyle.fontName := getViewType(self.visibleChildren()->at(2));
}

mapping Notation::Shape::shapeToStructuredActivityNodeShape() : UMLDI::StructuredActivityNodeShape
	inherits Notation::Shape::shapeToActionShape, Notation::Shape::shapeToActivityGroupShape, Notation::Shape::shapeToElementWithActivityNodesShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::StructuredActivityNode) };

mapping Notation::Shape::shapeToExpansionRegionShape() : UMLDI::ExpansionRegionShape
	inherits Notation::Shape::shapeToStructuredActivityNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ExpansionRegion) }
{
	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::ExpansionNode));
	expansionNodeShape += children.oclAsType(Notation::Shape)->map shapeToExpansionNodeShape();
}

mapping Notation::Shape::shapeToGateShape() : UMLDI::GateShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Gate) };

mapping Notation::Shape::shapeToLifelineShape() : UMLDI::LifelineShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Lifeline) }
{
	var children := self.visibleChildren()->select(element.oclIsKindOf(UML::InteractionFragment));
	// Timing diagrams nest the fragments on lifelines in compartments, skip such compartments
	if getViewType(self.diagram) = timingDiagramType then
		children := self.visibleChildren().visibleChildren()->select(
			element.oclIsKindOf(UML::StateInvariant) or 
			element.oclIsKindOf(UML::DestructionOccurrenceSpecification))->asOrderedSet()
	endif;
	
	subfragmentShape += children.oclAsType(Notation::Shape)->map toTopUmlDiagramElement().
		oclAsType(UMLDI::InteractionFragmentShape);
	
	if getViewType(self.diagram) = timingDiagramType then	
		subfragmentShape := subfragmentShape->sortedBy(bounds.x)
	else if getViewType(self.diagram) = sequenceDiagramType then
		subfragmentShape := subfragmentShape->sortedBy(bounds.y)
	endif endif;
		
	children := self.visibleChildren()->select(oclIsKindOf(Notation::Shape) and element.oclIsKindOf(UML::Lifeline));
	nestedLifelineShape += children.oclAsType(Notation::Shape)->map shapeToLifelineShape();
	
	var labels = self.visibleChildren().visibleChildren()->select(c|getViewType(c) = constraintLabelType);
	labels->forEach(label) {
		var id := label.eAnnotations.details->any(key='org.eclipse.papyrus.uml.diagram.timing.StateDefinitionViewID').value;
		var si := self.element.oclAsType(UML::Lifeline).coveredBy->any(oclIsKindOf(UML::StateInvariant) and
			eAnnotations.details->any(key='org.eclipse.papyrus.uml.diagram.timing.StateInvariantStateDefinitionId').value = id);
		var constLabel = label.map nodeToConstraintLabel();
		constLabel.umlModelElement := si;
		constraintLabel += constLabel;
	};
}

mapping Notation::Shape::shapeToInteractionFragmentShape() : UMLDI::InteractionFragmentShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InteractionFragment) };

mapping Notation::Shape::shapeToDestructionOccurrenceSpecificationShape() : UMLDI::InteractionFragmentShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::DestructionOccurrenceSpecification) }
{
	if getViewType(self.diagram) = timingDiagramType  then {
		bounds.x := bounds.x - 5 + 3;		
		bounds.y := bounds.y - 5;		
		bounds.width := bounds.width + 10;		
		bounds.height := bounds.height + 10;		
	}endif;
}

abstract mapping Notation::Shape::shapeToInteractionFragmentWithGatesShape() : UMLDI::InteractionFragmentWithGatesShape
	inherits Notation::Shape::shapeToInteractionFragmentShape
{
	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::Gate));
	gateShape += children.oclAsType(Notation::Shape)->map shapeToGateShape();
}

abstract mapping Notation::Shape::shapeToInteractionFragmentWithSubfragmentsShape() : UMLDI::InteractionFragmentWithSubfragmentsShape
	inherits Notation::Shape::shapeToInteractionFragmentShape
{
	var compartment := self.visibleChildren()->selectOne(c|subfragmentCompartmentType->includes(getViewType(c)));
	subfragmentCompartment := compartment.map nodeToSubfragmentCompartment();
}

mapping Notation::Shape::shapeToInteractionUseShape() : UMLDI::InteractionUseShape
	inherits Notation::Shape::shapeToInteractionFragmentWithGatesShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InteractionUse) }
{
	var label := self.visibleChildren()->selectOne(c|typeLabelType = getViewType(c));
	typeLabel := label.map nodeToTypeLabel();
}

mapping Notation::Shape::shapeToCombinedFragmentShape() : UMLDI::CombinedFragmentShape
	inherits Notation::Shape::shapeToInteractionFragmentWithGatesShape,
			 Notation::Shape::shapeToInteractionFragmentWithSubfragmentsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::CombinedFragment) }
{
	var cf := self.element.oclAsType(UML::CombinedFragment);
	
	// create the main (header) label of a combined fragment since it is not persisted in Papyrus (except for coregion)
	if self.children->notEmpty() then {
		mainLabel := object UMLDI::MainLabel {
			umlModelElement := result.umlModelElement;
			var b = getCombinedFragmentLabelBounds(self);
			bounds := object DC::Bounds {
				x := b.x; y := b.y; width := b.width; height := b.height;
			};
			// account for multiplicity on loop fragments by increasing the width
			if self.element.oclAsType(UML::CombinedFragment).interactionOperator = UML::InteractionOperatorKind::loop then {
				if cf.operand->notEmpty() and cf.operand.guard->notEmpty() then {
					var g := cf.operand.guard;
					if g.minint->notEmpty() and g.maxint->notEmpty() then
						if g.minint.integerValue() = g.maxint.integerValue() then
							bounds.width := bounds.width * 1.75
						else
							bounds.width := bounds.width * 2.25
						endif
					endif
				} endif
			} endif;
		 };
	} endif;
}

mapping Notation::Shape::shapeToInteractionOperandShape() : UMLDI::InteractionOperandShape
	inherits Notation::Shape::shapeToInteractionFragmentWithSubfragmentsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InteractionOperand) }
{
	// treat the guard label as the main label of the operand
	var label := self.visibleChildren()->selectOne(c|guardLabelType = getViewType(c));
	mainLabel := label.map nodeToMainLabel();
	mainLabel.umlModelElement := result.umlModelElement;
	
	subfragmentCompartment := object UMLDI::SubfragmentCompartment {
		bounds := self.bounds();
		umlModelElement := self.element.oclAsType(UML::InteractionOperand);
		topUmlDiagramElement += self.visibleChildren()->excluding(label)->map toTopUmlDiagramElement();
	};
}

mapping Notation::Shape::shapeToExecutionSpecificationShape() : UMLDI::ExecutionSpecificationShape
	inherits Notation::Shape::shapeToInteractionFragmentShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ExecutionSpecification) };

mapping Notation::Shape::shapeToTimeConstraintShape() : UMLDI::TimeConstraintShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::TimeConstraint) }
{
	if result.mainLabel->notEmpty() then {
		result.bounds.x := result.mainLabel.bounds.x;
		result.bounds.y := result.mainLabel.bounds.y;
		result.bounds.width := result.mainLabel.bounds.width;
		result.bounds.height := result.mainLabel.bounds.height;
	} endif;
}

mapping Notation::Shape::shapeToDurationConstraintShape() : UMLDI::DurationConstraintShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::DurationConstraint) };

mapping Notation::Shape::shapeToStateInvariantShape() : UMLDI::StateInvariantShape
	inherits Notation::Shape::shapeToInteractionFragmentShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::StateInvariant) }
{
	if getViewType(self.diagram) = sequenceDiagramType then {
		var e := self.element.oclAsType(UML::StateInvariant);
		useStateShape := e.name <> null and e.name.length()>0;
	} else if getViewType(self.diagram) = timingDiagramType then {
		useStateShape := getViewType(self) = compactStateInvariantShapeType;
		var siblings := self.container().oclAsType(Notation::Node).children;
		var inMiddle := siblings->subOrderedSet(siblings->indexOf(self)+1, siblings->size())->exists(element.oclIsKindOf(UML::StateInvariant));
		if not useStateShape and inMiddle then {
			bounds.x := bounds.x+2;
			bounds.width := bounds.width+2;
		} endif;
	} endif endif;
}

//-------------------------------------------------------------------------------------

mapping Notation::Edge::toTopUmlDiagramElement() : UMLDI::TopUmlDiagramElement
	disjuncts Notation::Edge::edgeToTransitionEdge,
			  Notation::Edge::edgeToConnectorEdge,
			  Notation::Edge::edgeToGeneralizationEdge,
			  Notation::Edge::edgeToInterfaceRealizationEdge,
			  Notation::Edge::edgeToComponentRealizationEdge,
			  Notation::Edge::edgeToSubstitutionEdge,
			  Notation::Edge::edgeToRealizationEdge,
			  Notation::Edge::edgeToManifestationEdge,
			  Notation::Edge::edgeToAbstractionEdge,
			  Notation::Edge::edgeToUsageEdge,
			  Notation::Edge::edgeToDeploymentEdge,
			  Notation::Edge::edgeToDependencyEdge,
			  Notation::Edge::edgeToElementImportEdge,
			  Notation::Edge::edgeToPackageImportEdge,
			  Notation::Edge::edgeToPackageMergeEdge,
			  Notation::Edge::edgeToProfileApplicationEdge,
			  Notation::Edge::edgeToInformationFlowEdge,
			  Notation::Edge::edgeToGeneralizationSetEdge,
			  Notation::Edge::edgeToPropertyEdge,
			  Notation::Edge::edgeToExtensionEdgeEdge,
			  Notation::Edge::edgeToAssociationClassEdge,
			  Notation::Edge::edgeToAssociationEdge,
			  Notation::Edge::edgeToInstanceSpecificationEdge,
			  Notation::Edge::edgeToTemplateBindingEdge,
			  Notation::Edge::edgeToExtendEdge,
			  Notation::Edge::edgeToIncludeEdge,
			  Notation::Edge::edgeToContainmentEdge,
			  Notation::Edge::edgeToAttachmentEdge,
			  Notation::Edge::edgeToRepresentationEdge,
			  Notation::Edge::edgeToPathEdge,
			  Notation::Edge::edgeToControlFlowEdge,
			  Notation::Edge::edgeToObjectFlowEdge,
			  Notation::Edge::edgeToExceptionHandlerEdge,
			  Notation::Edge::edgeToMessageEdge,
			  Notation::Edge::edgeToGeneralOrderingEdge;

abstract mapping Notation::Edge::edgeToUmlEdge() : UMLDI::UmlEdge
	inherits Notation::View::viewToTopUmlDiagramElement
{
	if mainLabel.oclIsUndefined() then {
		var label := self.visibleChildren()->selectOne(c|getViewType(c) = stereotypeLabelType);
		mainLabel := label.map nodeToMainLabel();
	} endif;

	getPoints(self)->forEach(p) {
		waypoint += object DC::Point { x := p.x; y := p.y; };
	};
	var fontStyle := self.styles[Notation::FontStyle]->at(1);
	localUmlStyle := object UMLDI::UmlStyle {
		fontName := fontStyle.fontName;
		fontSize := fontStyle.fontHeight;
	};
	sourceUmlDiagramElement := self.source.late resolveone(UMLDI::UmlDiagramElement);
	targetUmlDiagramElement := self.target.late resolveone(UMLDI::UmlDiagramElement);
}

abstract mapping Notation::Edge::edgeToElementEdge() : UMLDI::ElementEdge
	inherits Notation::Edge::edgeToUmlEdge;

abstract mapping Notation::Edge::edgeToActivityEdgeEdge() : UMLDI::ActivityEdgeEdge
	inherits Notation::Edge::edgeToElementEdge
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = guardLabelType);
	guardLabel := label.map nodeToGuardLabel();

	label := self.visibleChildren()->selectOne(c|getViewType(c) = weightLabelType);
	weightLabel := label.map nodeToWeightLabel();
}

mapping Notation::Edge::edgeToContainmentEdge() : UMLDI::ContainmentEdge
	inherits Notation::Edge::edgeToUmlEdge
	when { getViewType(self) = containmentEdgeType }
{
	sourceUmlDiagramElement := self.source.container().late resolveone(UMLDI::UmlDiagramElement);
}

mapping Notation::Edge::edgeToAttachmentEdge() : UMLDI::AttachmentEdge
	inherits Notation::Edge::edgeToUmlEdge
	when { getViewType(self) = attachmentEdgeType }
{
	// a special case for attachment of TimeObservation in SequenceDiagram
	if self.source.container().oclAsType(Notation::Node).element.oclIsKindOf(UML::TimeObservation) then {
		if sourceUmlDiagramElement->isEmpty() then
			sourceUmlDiagramElement := self.source.container().late resolveone(UMLDI::UmlDiagramElement)
		endif;
		if targetUmlDiagramElement->isEmpty() then
			targetUmlDiagramElement := self.target.container().late resolveone(UMLDI::UmlDiagramElement)
		endif;
	} endif
}

mapping Notation::Edge::edgeToRepresentationEdge() : UMLDI::RepresentationEdge
	inherits Notation::Edge::edgeToUmlEdge
	when { getViewType(self) = representationEdgeType }
{
	var label = self.visibleChildren()->selectOne(c|getViewType(c) = representationLabelType);
	mainLabel := label.map nodeToMainLabel();
}

mapping Notation::Edge::edgeToPathEdge() : UMLDI::PathEdge
	inherits Notation::Edge::edgeToUmlEdge
	when { getViewType(self) = pathEdgeType }
{
	var labels = self.visibleChildren()->select(element.oclIsKindOf(UML::Message));
	messageLabel := labels->map nodeToMessageLabel();
}

mapping Notation::Edge::edgeToGeneralizationEdge() : UMLDI::GeneralizationEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Generalization) };
	
mapping Notation::Edge::edgeToElementImportEdge() : UMLDI::ElementImportEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ElementImport) }
{
	if (mainLabel.oclIsUndefined()) {
		var label = self.visibleChildren()->selectOne(c|getViewType(c) = aliasLabelType);
		mainLabel := label.map nodeToMainLabel();
	}
}

mapping Notation::Edge::edgeToPackageImportEdge() : UMLDI::PackageImportEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::PackageImport) };

mapping Notation::Edge::edgeToPackageMergeEdge() : UMLDI::PackageMergeEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::PackageMerge) };

mapping Notation::Edge::edgeToProfileApplicationEdge() : UMLDI::ProfileApplicationEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ProfileApplication) }
{
	if (mainLabel.oclIsUndefined()) {
		mainLabel := object UMLDI::MainLabel {
			umlModelElement := self.element.oclAsType(UML::Element);
			bounds := self.centerPoint();
		};
	}
}

mapping Notation::Edge::edgeToGeneralizationSetEdge() : UMLDI::GeneralizationSetEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::GeneralizationSet) }
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = constraintLabelType);
	constraintLabel := label.map nodeToConstraintLabel();
}

mapping Notation::Edge::edgeToInformationFlowEdge() : UMLDI::InformationFlowEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InformationFlow) }
{
	var label := self.visibleChildren()->selectOne(c|conveyedLabelType->includes(getViewType(c)));
	conveyedLabel := label.map nodeToConveyedLabel();
}

mapping Notation::Edge::edgeToDependencyEdge() : UMLDI::DependencyEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Dependency) }
{
	var boundProperty = self.element.oclAsType(UML::Dependency).client![UML::Property];

	var label := self.visibleChildren()->selectOne(c|getViewType(c) = targetRoleLabelType);
	roleLabel := label.map nodeToRoleLabel();
	if (not roleLabel.oclIsUndefined()) {
		roleLabel.umlModelElement := boundProperty;
	}
}

mapping Notation::Edge::edgeToAbstractionEdge() : UMLDI::AbstractionEdge
	inherits Notation::Edge::edgeToDependencyEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Abstraction) };

mapping Notation::Edge::edgeToUsageEdge() : UMLDI::UsageEdge
	inherits Notation::Edge::edgeToDependencyEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Usage) };

mapping Notation::Edge::edgeToDeploymentEdge() : UMLDI::DeploymentEdge
	inherits Notation::Edge::edgeToDependencyEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Deployment) }
{
	// reverse source and target
	sourceUmlDiagramElement := self.target.late resolveone(UMLDI::UmlDiagramElement);
	targetUmlDiagramElement := self.source.late resolveone(UMLDI::UmlDiagramElement);
	result.waypoint := result.waypoint->iterate(p; cv : OrderedSet(Point) = OrderedSet{} | cv->prepend(p));
}

mapping Notation::Edge::edgeToRealizationEdge() : UMLDI::RealizationEdge
	inherits Notation::Edge::edgeToAbstractionEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Realization) };

mapping Notation::Edge::edgeToManifestationEdge() : UMLDI::ManifestationEdge
	inherits Notation::Edge::edgeToAbstractionEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Manifestation) };

mapping Notation::Edge::edgeToInterfaceRealizationEdge() : UMLDI::InterfaceRealizationEdge
	inherits Notation::Edge::edgeToRealizationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InterfaceRealization) };

mapping Notation::Edge::edgeToComponentRealizationEdge() : UMLDI::ComponentRealizationEdge
	inherits Notation::Edge::edgeToRealizationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ComponentRealization) };

mapping Notation::Edge::edgeToSubstitutionEdge() : UMLDI::SubstitutionEdge
	inherits Notation::Edge::edgeToRealizationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Substitution) };

mapping Notation::Edge::edgeToExtendEdge() : UMLDI::ExtendEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Extend) };

mapping Notation::Edge::edgeToIncludeEdge() : UMLDI::IncludeEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Include) };

mapping Notation::Edge::edgeToPropertyEdge() : UMLDI::PropertyEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Association) and self.styles[Notation::EObjectValueStyle]->notEmpty() }
{
	var property_ := self.styles![Notation::EObjectValueStyle].eObjectValue.oclAsType(UML::Property);

	umlModelElement := property_;

	if (mainLabel.oclIsUndefined()) {
		var label := self.visibleChildren()->selectOne(c|getViewType(c) = targetRoleLabelType);
		mainLabel := label.map nodeToMainLabel();
		if (not mainLabel.oclIsUndefined()) {
			mainLabel.umlModelElement := property_;
		}
	};
	
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = targetMultiplicityLabelType);
	multiplicityLabel := label.map nodeToMultiplicityLabel();
	if (not multiplicityLabel.oclIsUndefined()) {
		multiplicityLabel.umlModelElement := property_;
	}
}

mapping Notation::Edge::edgeToAssociationEdge() : UMLDI::AssociationEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Association) and self.styles[Notation::EObjectValueStyle]->isEmpty() }
{
	var association = self.element.oclAsType(UML::Association);
	
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = sourceRoleLabelType);
	var newRoleLabel := label.map nodeToRoleLabel();
	if (not newRoleLabel.oclIsUndefined()) {
		newRoleLabel.umlModelElement := association.memberEnd->at(2);
		endRoleLabel += newRoleLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = targetRoleLabelType);
	newRoleLabel := label.map nodeToRoleLabel();
	if (not newRoleLabel.oclIsUndefined()) {
		newRoleLabel.umlModelElement := association.memberEnd->at(1);
		endRoleLabel += newRoleLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = sourceMultiplicityLabelType);
	var newMultiplicityLabel := label.map nodeToMultiplicityLabel();
	if (not newMultiplicityLabel.oclIsUndefined()) {
		newMultiplicityLabel.umlModelElement := association.memberEnd->at(1);
		endMultiplicityLabel += newMultiplicityLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = targetMultiplicityLabelType);
	newMultiplicityLabel := label.map nodeToMultiplicityLabel();
	if (not newMultiplicityLabel.oclIsUndefined()) {
		newMultiplicityLabel.umlModelElement := association.memberEnd->at(2);
		endMultiplicityLabel += newMultiplicityLabel;
	};
}

mapping Notation::Edge::edgeToAssociationClassEdge() : UMLDI::AssociationClassEdge
	inherits Notation::Edge::edgeToAssociationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::AssociationClass) };

mapping Notation::Edge::edgeToExtensionEdgeEdge() : UMLDI::ExtensionEdge
	inherits Notation::Edge::edgeToAssociationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Extension) };

mapping Notation::Edge::edgeToInstanceSpecificationEdge() : UMLDI::InstanceSpecificationEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InstanceSpecification) }
{
	var association = self.element.oclAsType(UML::InstanceSpecification).classifier![UML::Association];

	var label := self.visibleChildren()->selectOne(c|getViewType(c) = sourceRoleLabelType);
	var newRoleLabel := label.map nodeToRoleLabel();
	if (not newRoleLabel.oclIsUndefined()) {
		newRoleLabel.umlModelElement := association.memberEnd->at(2);
		endRoleLabel += newRoleLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = targetRoleLabelType);
	newRoleLabel := label.map nodeToRoleLabel();
	if (not newRoleLabel.oclIsUndefined()) {
		newRoleLabel.umlModelElement := association.memberEnd->at(1);
		endRoleLabel += newRoleLabel;
	};
}

mapping Notation::Edge::edgeToConnectorEdge() : UMLDI::ConnectorEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Connector) }
{
	var connector = self.element.oclAsType(UML::Connector);
	
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = sourceMultiplicityLabelType);
	var newMultiplicityLabel := label.map nodeToMultiplicityLabel();
	if (not newMultiplicityLabel.oclIsUndefined()) {
		newMultiplicityLabel.umlModelElement := connector._end->at(1);
		endMultiplicityLabel += newMultiplicityLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = targetMultiplicityLabelType);
	newMultiplicityLabel := label.map nodeToMultiplicityLabel();
	if (not newMultiplicityLabel.oclIsUndefined()) {
		newMultiplicityLabel.umlModelElement := connector._end->at(2);
		endMultiplicityLabel += newMultiplicityLabel;
	};
}

mapping Notation::Edge::edgeToTemplateBindingEdge() : UMLDI::TemplateBindingEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::TemplateBinding) }
{
	if (mainLabel.oclIsUndefined()) {
		var label := self.visibleChildren()->selectOne(c|getViewType(c) = templateParameterSubstitutionLabelType);
		mainLabel := label.map nodeToMainLabel();
	}
}

mapping Notation::Edge::edgeToTransitionEdge() : UMLDI::TransitionEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Transition) };

mapping Notation::Edge::edgeToControlFlowEdge() : UMLDI::ControlFlowEdge
	inherits Notation::Edge::edgeToActivityEdgeEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ControlFlow) };

mapping Notation::Edge::edgeToObjectFlowEdge() : UMLDI::ObjectFlowEdge
	inherits Notation::Edge::edgeToActivityEdgeEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ObjectFlow) }
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = selectionLabelType);
	selectionLabel := label.map nodeToSelectionLabel();

	label := self.visibleChildren()->selectOne(c|getViewType(c) = transformationLabelType);
	transformationLabel := label.map nodeToTransformationLabel();
}

mapping Notation::Edge::edgeToExceptionHandlerEdge() : UMLDI::ExceptionHandlerEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ExceptionHandler) }
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = typeLabelType);
	typeLabel := label.map nodeToTypeLabel();

	label := self.visibleChildren()->selectOne(c|getViewType(c) = iconLabelType);
	iconLabel := label.map nodeToIconLabel();
}

mapping Notation::Edge::edgeToMessageEdge() : UMLDI::MessageEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Message) };

mapping Notation::Edge::edgeToGeneralOrderingEdge() : UMLDI::GeneralOrderingEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::GeneralOrdering) };

//-------------------------------------------------------------------------------------

abstract mapping Notation::Node::nodeToUmlLabel() : UMLDI::UmlLabel
	inherits Notation::View::viewToUmlDiagramElement
{
	bounds := self.bounds();
}

mapping Notation::Node::nodeToListItemLabel() : UMLDI::ListItemLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Shape::nodeToListItemLabel() : UMLDI::ListItemLabel
	inherits Notation::Node::nodeToListItemLabel
{
	if not self.container().oclAsType(Notation::Node).transientChildren->includes(self) then
		localUmlStyle := object UMLDI::UmlStyle {
			fontName := self.fontName;
			fontSize := self.fontHeight;
		}
	endif;
}

mapping Notation::Node::nodeToMainLabel() : UMLDI::MainLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToRoleLabel() : UMLDI::RoleLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToMultiplicityLabel() : UMLDI::MultiplicityLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToConstraintLabel() : UMLDI::ConstraintLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToConveyedLabel() : UMLDI::ConveyedLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToGuardLabel() : UMLDI::GuardLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToWeightLabel() : UMLDI::WeightLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToSelectionLabel() : UMLDI::SelectionLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToTransformationLabel() : UMLDI::TransformationLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToTypeLabel() : UMLDI::TypeLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToIconLabel() : UMLDI::IconLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToMessageLabel() : UMLDI::MessageLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToStereotypeLabel() : UMLDI::StereotypeLabel
	inherits Notation::Node::nodeToUmlLabel
{
	umlModelElement := self.styles![EObjectValueStyle].eObjectValue.oclAsType(UML::Element);
}

//-------------------------------------------------------------------------------------

abstract mapping Notation::Node::nodeToUmlCompartment() : UMLDI::UmlCompartment
	inherits Notation::View::viewToUmlDiagramElement
{
	bounds := self.bounds();
}

abstract mapping Notation::Node::nodeToListCompartment() : UMLDI::ListCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	listItemLabel += self.visibleChildren()->map nodeToListItemLabel();	
}

abstract mapping Notation::Node::nodeToDiagramCompartment() : UMLDI::DiagramCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	topUmlDiagramElement += self.visibleChildren()->map toTopUmlDiagramElement();
}

abstract mapping Notation::Node::nodeToClassifierCompartment() : UMLDI::ClassifierCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	if (self.visibleChildren().layoutConstraint->exists(oclIsKindOf(Notation::Bounds))) { // heuristic
		layout := UMLDI::CompartmentLayout::diagram;
		topUmlDiagramElement += self.visibleChildren()->map toTopUmlDiagramElement();
	} else {
		layout := UMLDI::CompartmentLayout::list;
		listItemLabel += self.visibleChildren()->map nodeToListItemLabel();
	};
}

mapping Notation::Node::nodeToAttributeCompartment() : UMLDI::AttributeCompartment
	inherits Notation::Node::nodeToListCompartment;
	
mapping Notation::Node::nodeToOperationCompartment() : UMLDI::OperationCompartment
	inherits Notation::Node::nodeToListCompartment;

mapping Notation::Node::nodeToReceptionCompartment() : UMLDI::ReceptionCompartment
	inherits Notation::Node::nodeToListCompartment;

mapping Notation::Node::nodeToLiteralCompartment() : UMLDI::LiteralCompartment
	inherits Notation::Node::nodeToListCompartment;

mapping Notation::Node::nodeToSlotCompartment() : UMLDI::SlotCompartment
	inherits Notation::Node::nodeToListCompartment;
	
mapping Notation::Node::nodeToTemplateParameterCompartment() : UMLDI::TemplateParameterCompartment
	inherits Notation::Node::nodeToListCompartment;
	
mapping Notation::Node::nodeToExtensionPointCompartment() : UMLDI::ExtensionPointCompartment
	inherits Notation::Node::nodeToListCompartment;
	
mapping Notation::Node::nodeToPackagedElementCompartment() : UMLDI::PackagedElementCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToStructureCompartment() : UMLDI::StructureCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToUseCaseCompartment() : UMLDI::UseCaseCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToNestedClassifierCompartment() : UMLDI::NestedClassifierCompartment
	inherits Notation::Node::nodeToClassifierCompartment;
	
mapping Notation::Node::nodeToNestedArtifactCompartment() : UMLDI::NestedArtifactCompartment
	inherits Notation::Node::nodeToClassifierCompartment;

mapping Notation::Node::nodeToNestedNodeCompartment() : UMLDI::NestedNodeCompartment
	inherits Notation::Node::nodeToClassifierCompartment;

mapping Notation::Node::nodeToOwnedUseCaseCompartment() : UMLDI::OwnedUseCaseCompartment
	inherits Notation::Node::nodeToClassifierCompartment;

mapping Notation::Node::nodeToOwnedBehaviorCompartment() : UMLDI::OwnedBehaviorCompartment
	inherits Notation::Node::nodeToClassifierCompartment;

mapping Notation::Node::nodeToRegionCompartment() : UMLDI::RegionCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToSubvertexCompartment() : UMLDI::SubvertexCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToInternalBehaviorCompartment() : UMLDI::InternalBehaviorCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	listItemLabel += self.visibleChildren()->select(element.oclIsKindOf(Behavior))->map nodeToListItemLabel();	
	listItemLabel->forEach(label) { label.bounds.x := bounds.x + 3; };
	var first := listItemLabel->at(1);
	var last := listItemLabel->at(listItemLabel->size());
	bounds.y := first.bounds.y;
	bounds.height := last.bounds.y + last.bounds.height - bounds.y;
}

mapping Notation::Node::nodeToInternalTransitionCompartment() : UMLDI::InternalTransitionCompartment
	inherits Notation::Node::nodeToUmlCompartment 
{
	listItemLabel += self.visibleChildren()->select(element.oclIsKindOf(Transition))->map nodeToListItemLabel();	
	listItemLabel->forEach(label) { label.bounds.x := bounds.x + 3; };
	var f := listItemLabel->at(1);
	var l := listItemLabel->at(listItemLabel->size());
	bounds.y := f.bounds.y;
	bounds.height := l.bounds.y+l.bounds.height - bounds.y;
}

mapping Notation::Node::nodeToParameterCompartment() : UMLDI::ParameterCompartment
	inherits Notation::Node::nodeToListCompartment
{
	listItemLabel->forEach(label) { label.bounds.x := bounds.x; };
}

mapping Notation::Node::nodeToPreConditionCompartment() : UMLDI::PreConditionCompartment
	inherits Notation::Node::nodeToListCompartment
{
	listItemLabel->forEach(label) { label.bounds.x := bounds.x; };
}
	
mapping Notation::Node::nodeToPostConditionCompartment() : UMLDI::PostConditionCompartment
	inherits Notation::Node::nodeToListCompartment
{
	listItemLabel->forEach(label) { label.bounds.x := bounds.x; };
}
	
mapping Notation::Node::nodeToActivityNodeCompartment() : UMLDI::ActivityNodeCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	// do the following here instead of inheriting nodeToDiagramCompartment to filter out 
	// localPre/PostCondition shapes (they are rather labels to actions) and their attachments
	var directChildren := self.visibleChildren()->reject(element.oclIsKindOf(UML::Constraint) 
		and element.container().oclIsKindOf(UML::Action));
	topUmlDiagramElement += directChildren->map toTopUmlDiagramElement();
	
	// recursively collect nested subpartition compartments
	var nestedCompartments := self->closure(visibleChildren()->select(element.oclIsKindOf(UML::ActivityPartition)))
		.visibleChildren()->select(c|subpartitionCompartmentType->includes(getViewType(c)));
	// collect nested interruptible activity region compartments
	nestedCompartments += self.visibleChildren()->select(element.oclIsKindOf(UML::InterruptibleActivityRegion))
		.visibleChildren()->select(c|interruptibleActivityRegionCompartmentType->includes(getViewType(c)));
	// add the children contained in those nested compartments to this content compartment
	topUmlDiagramElement += nestedCompartments.visibleChildren()
		->select(not element.oclIsKindOf(UML::ActivityPartition))->map toTopUmlDiagramElement();
}

mapping Notation::Node::nodeToSubpartitionCompartment() : UMLDI::SubpartitionCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	topUmlDiagramElement += self.visibleChildren()->select(element.oclIsKindOf(UML::ActivityPartition))->map toTopUmlDiagramElement();
}

mapping Notation::Node::nodeToSubfragmentCompartment() : UMLDI::SubfragmentCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToStereotypeCompartment() : UMLDI::StereotypeCompartment
	inherits Notation::Node::nodeToListCompartment
{
	listItemLabel += self.transientChildren->select(visible)->map nodeToListItemLabel();	
}

//-------------------------------------------------------------------------------------

query Notation::View::visibleChildren() : OrderedSet(Notation::Node) {
	var visible := self.children->select(visible);

	var a := self.eAnnotations->any(source='guard.visibility');
	if a <> null and a.details->any(key='guard.visibility').value = 'false' then
		visible := visible->reject(c|getViewType(c) = guardLabelType) 
	endif;
	
	a := self.eAnnotations->any(source='displayBehavior');
	if a <> null and a.details->any(key='displayBehavior').value = 'false' then
		visible := visible->reject(c|getViewType(c) = nameLabelType) 
	endif;
	
	return visible;
}

query Notation::Diagram::visibleEdges() : OrderedSet(Notation::Edge) {
	var edges := self.edges->select(visible);
	
	// ignore attachments to local pre/post conditions shapes (they will be labels)
	if getViewType(self) = activityDiagramType then
		edges := edges->reject(e|getViewType(e) = attachmentEdgeType and 
			e.target.element.oclIsKindOf(UML::Constraint) and 
				e.target.element.container() = e.source.element)
	endif;
	
	return edges;
}

query Notation::Node::bounds() : DC::Bounds {
	var b := getBounds(self);
	return object DC::Bounds {
		x := b.x; y := b.y; width := b.width; height := b.height;
	}
}

query Notation::Edge::centerPoint() : DC::Bounds {
	var points := getPoints(self);
	var s := points->at(points->size()-1);
	var e := points->at(points->size());
	return object DC::Bounds { x:= s.x+(e.x-s.x)/2; y:=s.y+(e.y-s.y)/2 };
}

query max(n1 : Real, n2 : Real) : Real {
	return if (n1 > n2) then n1 else n2 endif;
}

query abs(n : Real) : Real {
	return if (n<0) then -n else n endif;
}

query anchorPoint(bounds : Bounds, refX : Real, refY : Real) : Tuple(x: Real, y : Real) {
	var centerX := bounds.x + bounds.width/2;
	var centerY := bounds.y + bounds.height/2;
	var dx = refX - centerX;
	var dy = refY - centerY;
	var scale = 0.5 / max(abs(dx) / bounds.width, abs(dy) / bounds.height);
	dx := dx * scale;
	dy := dy * scale;
	return Tuple {x=centerX+dx, y=centerY+dy};
}

