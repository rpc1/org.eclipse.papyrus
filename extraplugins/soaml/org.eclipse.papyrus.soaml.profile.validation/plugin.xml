<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?eclipse version="3.4"?><plugin>
<extension point="org.eclipse.emf.validation.constraintProviders">
      <category id="org.eclipse.papyrus.soaml.profile.validation.soaml" mandatory="false" name="org.eclipse.papyrus.soaml.profile.validation.soaml"/>
      <constraintProvider cache="false" mode="Batch">
         <package namespaceUri="http://Papyrus/SoaML/1"/>
         <constraints categories="org.eclipse.papyrus.soaml.profile.validation.soaml">
            <constraint id="SoaML.Agent.isActive" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="isActive" severity="ERROR" statusCode="1">
               <message>Agent must be active</message><![CDATA[base_Class.isActive]]></constraint>
            <constraint id="SoaML.MessageType.noOwnedBehaviors" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="noOwnedBehaviors" severity="ERROR" statusCode="1">
               <message>MessageType cannot contain ownedBehaviors</message><![CDATA[self.base_Class<>null  implies self.base_Class.ownedBehavior->size()=0]]></constraint>
            <constraint id="SoaML.MessageType.noOwnedOperations" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="noOwnedOperations" severity="ERROR" statusCode="1">
               <message>MessageType cannot contain ownedOperation</message><![CDATA[if self.base_Class<>null 
then self.base_Class.ownedOperation->size()=0  
else
	 if self.base_DataType<>null 
	 then self.base_DataType.ownedOperation->size()=0
	 else self.base_Signal<>null implies true endif  
endif]]></constraint>
            <constraint id="SoaML.MessageType.publicAttributes" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="publicAttributes" severity="ERROR" statusCode="1">
               <message>All ownedAttributes must be Public</message><![CDATA[if self.base_Class<>null then self.base_Class.attribute->size()>0 implies self.base_Class.attribute->forAll (a|a.visibility=UML::VisibilityKind::public)
 else 
	  (if self.base_DataType<>null then 
		  	self.base_DataType.attribute->size()>0 implies self.base_DataType.attribute->forAll(a|a.visibility=UML::VisibilityKind::public)
 		else 
  			self.base_Signal.attribute->size()>0 implies self.base_Signal.attribute-> forAll (a|a.visibility=UML::VisibilityKind::public)
		endif)
 endif]]></constraint>
            <constraint id="SoaML.ServiceContract.RoleType" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="RoleType" severity="ERROR" statusCode="1">
               <message>role type of ServiceContract must be a ServiceInterface or UML Interface or Class stereotyped as Provider or Consumer.</message><![CDATA[  self.base_Collaboration.role-> notEmpty()  implies self.base_Collaboration.role-> forAll(role|
		role.type.oclIsTypeOf(UML::Interface) 
	or 
		(role.type.oclIsTypeOf(UML::Class)	and 
		(role.type.oclIsTypeOf(UML::Class) implies (role.type.getAppliedStereotypes()->select(s|s.name='Provider')->size()>0 
			and  role.type.getAppliedStereotypes()->select(s|s.name='Consumer') ->size()>0
		)
			or  role.type.getAppliedStereotypes()->select(s| s.name='ServiceInterface') ->size()>0
		))) ]]></constraint>
            <constraint id="SoaML.ServiceContract.AttachedBehaviorCompatibility" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="AttachedBehaviorCompatibility" severity="ERROR" statusCode="1">
               <message>Attached behavior should be compatible with the parts of the ServiceContract</message><![CDATA[   self.base_Collaboration.ownedBehavior->size()>0 implies (
	self.base_Collaboration.ownedBehavior->asOrderedSet()->first().oclIsTypeOf(UML::Interaction) implies
		let attachedInteraction=self.base_Collaboration.ownedBehavior->asOrderedSet()->first().oclAsType(UML::Interaction),
		lifelines=self.base_Collaboration.ownedBehavior->asOrderedSet()->first().oclAsType(UML::Interaction).lifeline,
		messages= self.base_Collaboration.ownedBehavior->asOrderedSet()->first().oclAsType(UML::Interaction).message,
		messOccuSpec=self.base_Collaboration.ownedBehavior->asOrderedSet()->first().oclAsType(UML::Interaction).fragment
		->select(f|f.oclIsTypeOf(MessageOccurrenceSpecification)) in 
		lifelines->size()>0 implies lifelines->forAll(l| self.base_Collaboration.role -> includes(l.oclAsType(UML::Lifeline).represents)  ) 
		and 
		messages->size()>0 implies messages 
		--signature of messages should be one of the operations or signal of the corresponding Service Declaration
		->forAll(m|m.signature.oclIsTypeOf(Operation) implies 
			m.receiveEvent->asOrderedSet()->first().oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()
			->first().oclAsType(Sequence)->asOrderedSet()->first().oclAsType(Lifeline).represents.type.oclAsType(Classifier).ownedElement->select(oclIsTypeOf(Operation))
			->includes(m.signature.oclAsType(Operation)) and 
				m.signature.oclIsTypeOf(Signal) implies 
				m.sendEvent->asOrderedSet()->first().oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()
				->first().oclAsType(Sequence)->asOrderedSet()->first().oclAsType(Lifeline).represents.type.oclAsType(Classifier).ownedElement->select(oclIsTypeOf(Signal))
			->includes(m.signature.oclAsType(Signal)
			))  ) ]]></constraint>
            <constraint id="SoaML.Request.requestType" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="requestType" severity="ERROR" statusCode="1">
               <message>The type of a Request must be a ServiceInterface, an Interface, a provider or a consumer</message><![CDATA[ let portType: Type=  base_Port.type in
 portType.getAppliedStereotypes()->select(s|s.name='ServiceInterface' or s.name='Consumer')->size()=1 or portType.oclIsTypeOf(Interface) ]]></constraint>
            <constraint id="SoaML.Request.isConjugatedTrue" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="isConjugatedTrue" severity="ERROR" statusCode="1">
               <message>Request must be Conjugated</message><![CDATA[base_Port.isConjugated]]></constraint>
            <constraint id="SoaML.Participant.noRealizedUsedInterface" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="noRealizedUsedInterface" severity="ERROR" statusCode="1">
               <message>Participant cannot realize or use Interfaces directly</message><![CDATA[Realization.allInstances()->select(r|r.client->includes(self.base_Class))->size()=0 and 
Usage.allInstances()->select(r|r.client->includes(self.base_Class))->size()=0]]></constraint>
            <constraint id="SoaML.Participant.portTypes" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="portTypes" severity="ERROR" statusCode="1">
               <message>Port must be a Request or a Service</message><![CDATA[  let portsSet: OrderedSet(UML::Port)= self.base_Class.ownedPort() in
  portsSet->size()>0 implies 
  portsSet->forAll(p|p.getAppliedStereotypes()->select(s|s.name='Request' or s.name='Service')->size()=1 )]]></constraint>
            <constraint id="SoaML.ServiceInterface.partsTypesOfServiceInterface" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="partsTypesOfServiceInterface" severity="ERROR" statusCode="1">
               <message>All parts of a ServiceInterface must be typed by the Interfaces realized or used by the ServiceInterface</message><![CDATA[if self.base_Interface.oclIsUndefined()
then self.base_Class.ownedAttribute->forAll(a|self.base_Class.getAllUsedInterfaces()->includes(a.type) or 
	self.base_Class.allRealizedInterfaces()->includes(a.type)
)
else 
	self.base_Interface.ownedAttribute->forAll(a|self.base_Interface.getAllUsedInterfaces()->includes(a.type) or 	
		self.base_Interface.allRealizedInterfaces()->includes(a.type)
	)
endif]]></constraint>
            <constraint id="SoaML.ServicesArchitecture.participantsRoleCompatibility" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="participantsRoleCompatibility" severity="ERROR" statusCode="1">
               <message>Each participant satisfying roles in a ServicesArchitecture shall have a port for each role binding attached to that participant.</message><![CDATA[let properties : Set (UML::ConnectableElement) = self.base_Collaboration.role,
collBUses: Set(UML::Element)= self.base_Collaboration.collaborationUse in
collBUses->notEmpty() implies 
-- Each participant satisfying roles in a ServicesArchitecture shall have a port for each role binding attached to that participant. 
--This port shall have a type compliant with the type of the role used in the ServiceContract.
collBUses.oclAsType(UML::CollaborationUse).roleBinding-> forAll(rb| let 
	portTypesOfSupplier=	rb.oclAsType(UML::Dependency).supplier->select(s|s.oclIsTypeOf(UML::Property))->select(s|s.oclAsType(UML::Property).type.oclIsTypeOf(Class))->collect(oclAsType(UML::Property).type.oclAsType(Class).getAllAttributes())->select(att|att.oclIsTypeOf(UML::Port))->collect(oclAsType(UML::Port).type) , clientType=rb.oclAsType(UML::Dependency).client->select(s|s.oclIsTypeOf(UML::Property))->collect(t:UML::NamedElement|t.oclAsType(UML::Property).type)->asOrderedSet()->first()in 	
portTypesOfSupplier->includes(clientType)--1. The role correspond to a port type on the supplier.
--2. the supplier has a port type that specializes the type of the role.
or(clientType.oclAsType(Classifier).generalization.general->closure(general)->includes(portTypesOfSupplier)) 
--3. the supplier has a port type that realizes the type of the role.
or(clientType.oclAsType(Classifier).getRelationships().oclAsType(UML::Realization)->includes(portTypesOfSupplier)) 
--4. the supplier has a port type that contains at least the ownedAttributes and ownedOperations of the role.
or(portTypesOfSupplier.oclAsType(Classifier).getAllAttributes()->includesAll(clientType.oclAsType(Classifier).getAllAttributes()) 
	and portTypesOfSupplier.oclAsType(Classifier).getAllOperations()->includesAll(clientType.oclAsType(Classifier).getAllOperations())
) )]]></constraint>
            <constraint id="SoaML.ServicesArchitecture.partsTypes" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="partsTypes" severity="ERROR" statusCode="1">
               <message>The parts of a ServicesArchitecture must be typed by a Participant or capability</message><![CDATA[let properties : Set (UML::ConnectableElement) = self.base_Collaboration.role,
collBUses: Set(UML::Element)= self.base_Collaboration.collaborationUse in
properties->notEmpty() implies 
properties-> forAll(p|p.type->exists(p|p.getAppliedStereotypes()->select(s|s.name='Participant' or s.name='Capability' or s.name='Agent')->size()=1) )
]]></constraint>
            <constraint id="SoaML.CollaborationUse.RoleBindingClientSupplierCompatibility" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="RoleBindingClientSupplierCompatibility" severity="ERROR" statusCode="1">
               <message>If the CollaborationUse has isStrict=true, then the parts must be compatible with the roles they are bound to. </message><![CDATA[--only in case of defining Contract collaboratinUse inside the ServiceInterface
--If the CollaborationUse has isStrict=true, then the parts must be compatible with the roles they are bound to.
self.isStrict=true and self.base_CollaborationUse.owner.oclIsTypeOf(Classifier) 
and  self.base_CollaborationUse.type.oclAsType(UML::Collaboration).getAppliedStereotypes()->select(s|s.name='ServiceContract')->size()=1 implies
--For parts to be compatible with a role, one of the following must be true:
--1. The role and part have the same type.
self.base_CollaborationUse.roleBinding-> forAll(rb|
	(let supplierType =(rb.oclAsType(UML::Dependency).supplier->select(s|s.oclIsTypeOf(UML::Property))->select(s|s.oclAsType(UML::Property).type.oclIsTypeOf(Class))
	->collect(oclAsType(UML::Property).type ->asOrderedSet()->first())),
	clientType= (rb.oclAsType(UML::Dependency).client->select(s|s.oclIsTypeOf(UML::Property))->collect(t:UML::NamedElement|t.oclAsType(UML::Property).type)->asOrderedSet()->first())in (
	supplierType= clientType
--2. The part (the supplier) has a type that specializes the type of the role.
or(clientType.oclAsType(Classifier).generalization.general->closure(general)->includes(supplierType)) 
--3. The part has a type that realizes the type of the role.
or(clientType.oclAsType(Classifier).getRelationships().oclAsType(UML::Realization)->includes(supplierType)) 
--4. The part has a type that contains at least the ownedAttributes and ownedOperations of the role. In general this is a
--special case of item 3 where the part has an Interface type that realizes another Interface.
or(supplierType.oclAsType(Classifier).getAllAttributes()->includesAll(clientType.oclAsType(Classifier).getAllAttributes()) 
	and supplierType.oclAsType(Classifier).getAllOperations()->includesAll(clientType.oclAsType(Classifier).getAllOperations())
) )
--5. The type of each role in a service contract shall have a uses dependency to the type of all roles that role is connected to.
)
)]]></constraint>
            <constraint id="SoaML.ServiceChannel.Onlybinaryconnectorsallowed" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="Onlybinaryconnectorsallowed" severity="ERROR" statusCode="1">
               <message>Only binary connection are allowed</message><![CDATA[self.base_Connector.end->size() = 2 
--and self.base_Connector.end->forAll(e|e.oclIsTypeOf(UML::Port)) ]]></constraint>
            <constraint id="SoaML.ServiceChannel.serviceChannelEndTypes" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="serviceChannelEndTypes" severity="ERROR" statusCode="1">
               <message>One end of a ServiceChannel must be a Request and the other a Service in an architecture</message><![CDATA[let portsSet: OrderedSet(UML::ConnectorEnd)= self.base_Connector.end ->select(e|e.oclIsTypeOf(UML::Port)) in
  portsSet->size()>0 implies 
  portsSet->forAll(p|p.getAppliedStereotypes()->select(s|s.name='Request' or s.name='Service')->size()=1 )
]]></constraint>
            <constraint id="SoaML.ServiceChannel.Compatibility" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="Compatibility" severity="ERROR" statusCode="1">
               <message>The Request and Service connected by a ServiceChannel must be compatible</message><![CDATA[let 
 requestTypeClassifier: UML::Classifier=self.base_Connector.end->select(p|p.oclIsTypeOf(UML::Port) and  	oclIsTypeOf(SoaML::Request))
 -> select(p|p.oclAsType(UML::Port).type.oclIsTypeOf(Classifier))->first().oclAsType(UML::Port).type.oclAsType(Classifier),
 serviceTypeClassifier: UML::Classifier=self.base_Connector.end->select(p|p.oclIsTypeOf(UML::Port) and oclIsTypeOf(SoaML::Service))
 ->select(p|p.oclAsType(UML::Port).type.oclIsTypeOf(Classifier))->first().oclAsType(UML::Port).type.oclAsType(Classifier)  in 
--The Request and Service connected by a ServiceChannel must be compatible
  --1. The Request and Service have the same type, either an Interface or ServiceInterface.
not requestTypeClassifier.oclIsUndefined() and not serviceTypeClassifier.oclIsUndefined() implies requestTypeClassifier=serviceTypeClassifier or
 --2. The type of the Service is a specialization or realization of the type of the Request.  --2 implies 1
serviceTypeClassifier.Generalization.general->closure(general)-> includes(requestTypeClassifier) or
 requestTypeClassifier.allUsedInterfaces()->includes(serviceTypeClassifier) or
 --3. The Request and Service have compatible needs and capabilities respectively. This means the Service must provide an 
--Operation for every Operation used through the Request, the Request must provide an Operation for every Operation used 
--through the Service, and the protocols for how the capabilities are compatible between the Request and Service. 
(requestTypeClassifier.allUsedInterfaces().getAllOperations()->includesAll(serviceTypeClassifier.allRealizedInterfaces().getAllOperations() )and 
	requestTypeClassifier.allRealizedInterfaces().getAllOperations()-> includesAll(serviceTypeClassifier.allUsedInterfaces().getAllOperations()))]]></constraint>
            <constraint id="SoaML.Service.serviceType" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="serviceType" severity="ERROR" statusCode="1">
               <message>The type of a Service must be a ServiceInterface, an Interface, a provider or a consumer</message><![CDATA[  if base_Port.type.oclIsUndefined() then false else
  let portType: Type=  base_Port.type in
 portType.getAppliedStereotypes()->select(s|s.name='ServiceInterface' or  s.name='Provider' )->size()=1 or portType.oclIsTypeOf(Interface)
 endif ]]></constraint>
            <constraint id="SoaML.Service.isConjugatedFalse" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="isConjugatedFalse" severity="ERROR" statusCode="1">
               <message>Service  Port must not be Conjugated</message><![CDATA[ 
  not base_Port.isConjugated]]></constraint>
            <constraint id="SoaML.Port.connectorRequired" isEnabledByDefault="true" lang="OCLpivot" mode="Batch" name="connectorRequired" severity="ERROR" statusCode="1">
               <message>connectorRequired not valid</message><![CDATA[--self.connectorRequired=true implies self.base_Port.owner.
true]]></constraint>
         </constraints>
      </constraintProvider>
   </extension>
   <extension point="org.eclipse.emf.validation.constraintBindings">
      <clientContext id="PortClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.PortClientSelector"/>
      </clientContext>
      <binding context="PortClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.Port.connectorRequired"/>
      </binding>
      <clientContext id="RequestClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.RequestClientSelector"/>
      </clientContext>
      <binding context="RequestClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.Request.requestType"/>
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.Request.isConjugatedTrue"/>
      </binding>
      <clientContext id="MessageTypeClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.MessageTypeClientSelector"/>
      </clientContext>
      <binding context="MessageTypeClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.MessageType.noOwnedBehaviors"/>
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.MessageType.noOwnedOperations"/>
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.MessageType.publicAttributes"/>
      </binding>
      <clientContext id="AgentClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.AgentClientSelector"/>
      </clientContext>
      <binding context="AgentClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.Agent.isActive"/>
      </binding>
      <clientContext id="ServiceClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.ServiceClientSelector"/>
      </clientContext>
      <binding context="ServiceClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.Service.serviceType"/>
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.Service.isConjugatedFalse"/>
      </binding>
      <clientContext id="ServicesArchitectureClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.ServicesArchitectureClientSelector"/>
      </clientContext>
      <binding context="ServicesArchitectureClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.ServicesArchitecture.participantsRoleCompatibility"/>
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.ServicesArchitecture.partsTypes"/>
      </binding>
      <clientContext id="ServiceChannelClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.ServiceChannelClientSelector"/>
      </clientContext>
      <binding context="ServiceChannelClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.ServiceChannel.Onlybinaryconnectorsallowed"/>
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.ServiceChannel.serviceChannelEndTypes"/>
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.ServiceChannel.Compatibility"/>
      </binding>
      <clientContext id="ServiceContractClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.ServiceContractClientSelector"/>
      </clientContext>
      <binding context="ServiceContractClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.ServiceContract.RoleType"/>
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.ServiceContract.AttachedBehaviorCompatibility"/>
      </binding>
      <clientContext id="ServiceInterfaceClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.ServiceInterfaceClientSelector"/>
      </clientContext>
      <binding context="ServiceInterfaceClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.ServiceInterface.partsTypesOfServiceInterface"/>
      </binding>
      <clientContext id="CollaborationUseClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.CollaborationUseClientSelector"/>
      </clientContext>
      <binding context="CollaborationUseClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.CollaborationUse.RoleBindingClientSupplierCompatibility"/>
      </binding>
      <clientContext id="ParticipantClientContext">
         <selector class="org.eclipse.papyrus.soaml.profile.validation.selectors.ParticipantClientSelector"/>
      </clientContext>
      <binding context="ParticipantClientContext">
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.Participant.noRealizedUsedInterface"/>
         <constraint ref="org.eclipse.papyrus.soaml.profile.validation.SoaML.Participant.portTypes"/>
      </binding>
   </extension>
</plugin>
